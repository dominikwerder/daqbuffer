// This file is generated by rust-protobuf 2.24.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `EPICSEvent.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_24_1;

#[derive(PartialEq,Clone,Default)]
pub struct FieldValue {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    val: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldValue {
    fn default() -> &'a FieldValue {
        <FieldValue as ::protobuf::Message>::default_instance()
    }
}

impl FieldValue {
    pub fn new() -> FieldValue {
        ::std::default::Default::default()
    }

    // required string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string val = 2;


    pub fn get_val(&self) -> &str {
        match self.val.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::string::String) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::string::String {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::string::String {
        self.val.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FieldValue {
    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.val)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldValue {
        FieldValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FieldValue| { &m.name },
                |m: &mut FieldValue| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "val",
                |m: &FieldValue| { &m.val },
                |m: &mut FieldValue| { &mut m.val },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldValue>(
                "FieldValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldValue {
        static instance: ::protobuf::rt::LazyV2<FieldValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldValue::new)
    }
}

impl ::protobuf::Clear for FieldValue {
    fn clear(&mut self) {
        self.name.clear();
        self.val.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarString {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::protobuf::SingularField<::std::string::String>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarString {
    fn default() -> &'a ScalarString {
        <ScalarString as ::protobuf::Message>::default_instance()
    }
}

impl ScalarString {
    pub fn new() -> ScalarString {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required string val = 3;


    pub fn get_val(&self) -> &str {
        match self.val.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::string::String) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::string::String {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::string::String {
        self.val.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarString {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarString {
        ScalarString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarString| { &m.secondsintoyear },
                |m: &mut ScalarString| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarString| { &m.nano },
                |m: &mut ScalarString| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "val",
                |m: &ScalarString| { &m.val },
                |m: &mut ScalarString| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarString| { &m.severity },
                |m: &mut ScalarString| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarString| { &m.status },
                |m: &mut ScalarString| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarString| { &m.repeatcount },
                |m: &mut ScalarString| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarString| { &m.fieldvalues },
                |m: &mut ScalarString| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarString| { &m.fieldactualchange },
                |m: &mut ScalarString| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarString>(
                "ScalarString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarString {
        static instance: ::protobuf::rt::LazyV2<ScalarString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarString::new)
    }
}

impl ::protobuf::Clear for ScalarString {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarByte {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarByte {
    fn default() -> &'a ScalarByte {
        <ScalarByte as ::protobuf::Message>::default_instance()
    }
}

impl ScalarByte {
    pub fn new() -> ScalarByte {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required bytes val = 3;


    pub fn get_val(&self) -> &[u8] {
        match self.val.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<u8> {
        self.val.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarByte {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarByte {
        ScalarByte::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarByte| { &m.secondsintoyear },
                |m: &mut ScalarByte| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarByte| { &m.nano },
                |m: &mut ScalarByte| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "val",
                |m: &ScalarByte| { &m.val },
                |m: &mut ScalarByte| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarByte| { &m.severity },
                |m: &mut ScalarByte| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarByte| { &m.status },
                |m: &mut ScalarByte| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarByte| { &m.repeatcount },
                |m: &mut ScalarByte| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarByte| { &m.fieldvalues },
                |m: &mut ScalarByte| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarByte| { &m.fieldactualchange },
                |m: &mut ScalarByte| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarByte>(
                "ScalarByte",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarByte {
        static instance: ::protobuf::rt::LazyV2<ScalarByte> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarByte::new)
    }
}

impl ::protobuf::Clear for ScalarByte {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarByte {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarByte {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarShort {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::std::option::Option<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarShort {
    fn default() -> &'a ScalarShort {
        <ScalarShort as ::protobuf::Message>::default_instance()
    }
}

impl ScalarShort {
    pub fn new() -> ScalarShort {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required sint32 val = 3;


    pub fn get_val(&self) -> i32 {
        self.val.unwrap_or(0)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: i32) {
        self.val = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarShort {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.val {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarShort {
        ScalarShort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarShort| { &m.secondsintoyear },
                |m: &mut ScalarShort| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarShort| { &m.nano },
                |m: &mut ScalarShort| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "val",
                |m: &ScalarShort| { &m.val },
                |m: &mut ScalarShort| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarShort| { &m.severity },
                |m: &mut ScalarShort| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarShort| { &m.status },
                |m: &mut ScalarShort| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarShort| { &m.repeatcount },
                |m: &mut ScalarShort| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarShort| { &m.fieldvalues },
                |m: &mut ScalarShort| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarShort| { &m.fieldactualchange },
                |m: &mut ScalarShort| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarShort>(
                "ScalarShort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarShort {
        static instance: ::protobuf::rt::LazyV2<ScalarShort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarShort::new)
    }
}

impl ::protobuf::Clear for ScalarShort {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarShort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarShort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarInt {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::std::option::Option<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarInt {
    fn default() -> &'a ScalarInt {
        <ScalarInt as ::protobuf::Message>::default_instance()
    }
}

impl ScalarInt {
    pub fn new() -> ScalarInt {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required sfixed32 val = 3;


    pub fn get_val(&self) -> i32 {
        self.val.unwrap_or(0)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: i32) {
        self.val = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarInt {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sfixed32()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += 5;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.val {
            os.write_sfixed32(3, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarInt {
        ScalarInt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarInt| { &m.secondsintoyear },
                |m: &mut ScalarInt| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarInt| { &m.nano },
                |m: &mut ScalarInt| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                "val",
                |m: &ScalarInt| { &m.val },
                |m: &mut ScalarInt| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarInt| { &m.severity },
                |m: &mut ScalarInt| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarInt| { &m.status },
                |m: &mut ScalarInt| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarInt| { &m.repeatcount },
                |m: &mut ScalarInt| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarInt| { &m.fieldvalues },
                |m: &mut ScalarInt| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarInt| { &m.fieldactualchange },
                |m: &mut ScalarInt| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarInt>(
                "ScalarInt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarInt {
        static instance: ::protobuf::rt::LazyV2<ScalarInt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarInt::new)
    }
}

impl ::protobuf::Clear for ScalarInt {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarInt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarEnum {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::std::option::Option<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarEnum {
    fn default() -> &'a ScalarEnum {
        <ScalarEnum as ::protobuf::Message>::default_instance()
    }
}

impl ScalarEnum {
    pub fn new() -> ScalarEnum {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required sint32 val = 3;


    pub fn get_val(&self) -> i32 {
        self.val.unwrap_or(0)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: i32) {
        self.val = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarEnum {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_sint32()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += ::protobuf::rt::value_varint_zigzag_size(3, v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.val {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarEnum {
        ScalarEnum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarEnum| { &m.secondsintoyear },
                |m: &mut ScalarEnum| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarEnum| { &m.nano },
                |m: &mut ScalarEnum| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "val",
                |m: &ScalarEnum| { &m.val },
                |m: &mut ScalarEnum| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarEnum| { &m.severity },
                |m: &mut ScalarEnum| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarEnum| { &m.status },
                |m: &mut ScalarEnum| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarEnum| { &m.repeatcount },
                |m: &mut ScalarEnum| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarEnum| { &m.fieldvalues },
                |m: &mut ScalarEnum| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarEnum| { &m.fieldactualchange },
                |m: &mut ScalarEnum| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarEnum>(
                "ScalarEnum",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarEnum {
        static instance: ::protobuf::rt::LazyV2<ScalarEnum> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarEnum::new)
    }
}

impl ::protobuf::Clear for ScalarEnum {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarFloat {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::std::option::Option<f32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarFloat {
    fn default() -> &'a ScalarFloat {
        <ScalarFloat as ::protobuf::Message>::default_instance()
    }
}

impl ScalarFloat {
    pub fn new() -> ScalarFloat {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required float val = 3;


    pub fn get_val(&self) -> f32 {
        self.val.unwrap_or(0.)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: f32) {
        self.val = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarFloat {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += 5;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.val {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarFloat {
        ScalarFloat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarFloat| { &m.secondsintoyear },
                |m: &mut ScalarFloat| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarFloat| { &m.nano },
                |m: &mut ScalarFloat| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "val",
                |m: &ScalarFloat| { &m.val },
                |m: &mut ScalarFloat| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarFloat| { &m.severity },
                |m: &mut ScalarFloat| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarFloat| { &m.status },
                |m: &mut ScalarFloat| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarFloat| { &m.repeatcount },
                |m: &mut ScalarFloat| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarFloat| { &m.fieldvalues },
                |m: &mut ScalarFloat| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarFloat| { &m.fieldactualchange },
                |m: &mut ScalarFloat| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarFloat>(
                "ScalarFloat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarFloat {
        static instance: ::protobuf::rt::LazyV2<ScalarFloat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarFloat::new)
    }
}

impl ::protobuf::Clear for ScalarFloat {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarFloat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarFloat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScalarDouble {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::std::option::Option<f64>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScalarDouble {
    fn default() -> &'a ScalarDouble {
        <ScalarDouble as ::protobuf::Message>::default_instance()
    }
}

impl ScalarDouble {
    pub fn new() -> ScalarDouble {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required double val = 3;


    pub fn get_val(&self) -> f64 {
        self.val.unwrap_or(0.)
    }
    pub fn clear_val(&mut self) {
        self.val = ::std::option::Option::None;
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: f64) {
        self.val = ::std::option::Option::Some(v);
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScalarDouble {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.val = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.val {
            my_size += 9;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.val {
            os.write_double(3, v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScalarDouble {
        ScalarDouble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &ScalarDouble| { &m.secondsintoyear },
                |m: &mut ScalarDouble| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &ScalarDouble| { &m.nano },
                |m: &mut ScalarDouble| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "val",
                |m: &ScalarDouble| { &m.val },
                |m: &mut ScalarDouble| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &ScalarDouble| { &m.severity },
                |m: &mut ScalarDouble| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &ScalarDouble| { &m.status },
                |m: &mut ScalarDouble| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &ScalarDouble| { &m.repeatcount },
                |m: &mut ScalarDouble| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &ScalarDouble| { &m.fieldvalues },
                |m: &mut ScalarDouble| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &ScalarDouble| { &m.fieldactualchange },
                |m: &mut ScalarDouble| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScalarDouble>(
                "ScalarDouble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScalarDouble {
        static instance: ::protobuf::rt::LazyV2<ScalarDouble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScalarDouble::new)
    }
}

impl ::protobuf::Clear for ScalarDouble {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val = ::std::option::Option::None;
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScalarDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScalarDouble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorString {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::protobuf::RepeatedField<::std::string::String>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorString {
    fn default() -> &'a VectorString {
        <VectorString as ::protobuf::Message>::default_instance()
    }
}

impl VectorString {
    pub fn new() -> VectorString {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated string val = 3;


    pub fn get_val(&self) -> &[::std::string::String] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.val, ::protobuf::RepeatedField::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorString {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.val {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        for v in &self.val {
            os.write_string(3, &v)?;
        };
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorString {
        VectorString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorString| { &m.secondsintoyear },
                |m: &mut VectorString| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorString| { &m.nano },
                |m: &mut VectorString| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "val",
                |m: &VectorString| { &m.val },
                |m: &mut VectorString| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorString| { &m.severity },
                |m: &mut VectorString| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorString| { &m.status },
                |m: &mut VectorString| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorString| { &m.repeatcount },
                |m: &mut VectorString| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorString| { &m.fieldvalues },
                |m: &mut VectorString| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorString| { &m.fieldactualchange },
                |m: &mut VectorString| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorString>(
                "VectorString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorString {
        static instance: ::protobuf::rt::LazyV2<VectorString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorString::new)
    }
}

impl ::protobuf::Clear for VectorString {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorChar {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorChar {
    fn default() -> &'a VectorChar {
        <VectorChar as ::protobuf::Message>::default_instance()
    }
}

impl VectorChar {
    pub fn new() -> VectorChar {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required bytes val = 3;


    pub fn get_val(&self) -> &[u8] {
        match self.val.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<u8> {
        self.val.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorChar {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorChar {
        VectorChar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorChar| { &m.secondsintoyear },
                |m: &mut VectorChar| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorChar| { &m.nano },
                |m: &mut VectorChar| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "val",
                |m: &VectorChar| { &m.val },
                |m: &mut VectorChar| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorChar| { &m.severity },
                |m: &mut VectorChar| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorChar| { &m.status },
                |m: &mut VectorChar| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorChar| { &m.repeatcount },
                |m: &mut VectorChar| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorChar| { &m.fieldvalues },
                |m: &mut VectorChar| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorChar| { &m.fieldactualchange },
                |m: &mut VectorChar| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorChar>(
                "VectorChar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorChar {
        static instance: ::protobuf::rt::LazyV2<VectorChar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorChar::new)
    }
}

impl ::protobuf::Clear for VectorChar {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorChar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorChar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorShort {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::std::vec::Vec<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorShort {
    fn default() -> &'a VectorShort {
        <VectorShort as ::protobuf::Message>::default_instance()
    }
}

impl VectorShort {
    pub fn new() -> VectorShort {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated sint32 val = 3;


    pub fn get_val(&self) -> &[i32] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<i32>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorShort {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.val.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(3, &self.val);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if !self.val.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.val))?;
            for v in &self.val {
                os.write_sint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorShort {
        VectorShort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorShort| { &m.secondsintoyear },
                |m: &mut VectorShort| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorShort| { &m.nano },
                |m: &mut VectorShort| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "val",
                |m: &VectorShort| { &m.val },
                |m: &mut VectorShort| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorShort| { &m.severity },
                |m: &mut VectorShort| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorShort| { &m.status },
                |m: &mut VectorShort| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorShort| { &m.repeatcount },
                |m: &mut VectorShort| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorShort| { &m.fieldvalues },
                |m: &mut VectorShort| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorShort| { &m.fieldactualchange },
                |m: &mut VectorShort| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorShort>(
                "VectorShort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorShort {
        static instance: ::protobuf::rt::LazyV2<VectorShort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorShort::new)
    }
}

impl ::protobuf::Clear for VectorShort {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorShort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorShort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorInt {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::std::vec::Vec<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorInt {
    fn default() -> &'a VectorInt {
        <VectorInt as ::protobuf::Message>::default_instance()
    }
}

impl VectorInt {
    pub fn new() -> VectorInt {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated sfixed32 val = 3;


    pub fn get_val(&self) -> &[i32] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<i32>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorInt {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_sfixed32_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.val.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.val.len() * 4) as u32) + (self.val.len() * 4) as u32;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if !self.val.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.val.len() * 4) as u32)?;
            for v in &self.val {
                os.write_sfixed32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorInt {
        VectorInt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorInt| { &m.secondsintoyear },
                |m: &mut VectorInt| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorInt| { &m.nano },
                |m: &mut VectorInt| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSfixed32>(
                "val",
                |m: &VectorInt| { &m.val },
                |m: &mut VectorInt| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorInt| { &m.severity },
                |m: &mut VectorInt| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorInt| { &m.status },
                |m: &mut VectorInt| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorInt| { &m.repeatcount },
                |m: &mut VectorInt| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorInt| { &m.fieldvalues },
                |m: &mut VectorInt| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorInt| { &m.fieldactualchange },
                |m: &mut VectorInt| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorInt>(
                "VectorInt",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorInt {
        static instance: ::protobuf::rt::LazyV2<VectorInt> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorInt::new)
    }
}

impl ::protobuf::Clear for VectorInt {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorInt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorEnum {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::std::vec::Vec<i32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorEnum {
    fn default() -> &'a VectorEnum {
        <VectorEnum as ::protobuf::Message>::default_instance()
    }
}

impl VectorEnum {
    pub fn new() -> VectorEnum {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated sint32 val = 3;


    pub fn get_val(&self) -> &[i32] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<i32>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorEnum {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_sint32_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.val.is_empty() {
            my_size += ::protobuf::rt::vec_packed_varint_zigzag_size(3, &self.val);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if !self.val.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32(::protobuf::rt::vec_packed_varint_zigzag_data_size(&self.val))?;
            for v in &self.val {
                os.write_sint32_no_tag(*v)?;
            };
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorEnum {
        VectorEnum::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorEnum| { &m.secondsintoyear },
                |m: &mut VectorEnum| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorEnum| { &m.nano },
                |m: &mut VectorEnum| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeSint32>(
                "val",
                |m: &VectorEnum| { &m.val },
                |m: &mut VectorEnum| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorEnum| { &m.severity },
                |m: &mut VectorEnum| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorEnum| { &m.status },
                |m: &mut VectorEnum| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorEnum| { &m.repeatcount },
                |m: &mut VectorEnum| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorEnum| { &m.fieldvalues },
                |m: &mut VectorEnum| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorEnum| { &m.fieldactualchange },
                |m: &mut VectorEnum| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorEnum>(
                "VectorEnum",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorEnum {
        static instance: ::protobuf::rt::LazyV2<VectorEnum> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorEnum::new)
    }
}

impl ::protobuf::Clear for VectorEnum {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorFloat {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::std::vec::Vec<f32>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorFloat {
    fn default() -> &'a VectorFloat {
        <VectorFloat as ::protobuf::Message>::default_instance()
    }
}

impl VectorFloat {
    pub fn new() -> VectorFloat {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated float val = 3;


    pub fn get_val(&self) -> &[f32] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<f32>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorFloat {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.val.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.val.len() * 4) as u32) + (self.val.len() * 4) as u32;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if !self.val.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.val.len() * 4) as u32)?;
            for v in &self.val {
                os.write_float_no_tag(*v)?;
            };
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorFloat {
        VectorFloat::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorFloat| { &m.secondsintoyear },
                |m: &mut VectorFloat| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorFloat| { &m.nano },
                |m: &mut VectorFloat| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "val",
                |m: &VectorFloat| { &m.val },
                |m: &mut VectorFloat| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorFloat| { &m.severity },
                |m: &mut VectorFloat| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorFloat| { &m.status },
                |m: &mut VectorFloat| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorFloat| { &m.repeatcount },
                |m: &mut VectorFloat| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorFloat| { &m.fieldvalues },
                |m: &mut VectorFloat| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorFloat| { &m.fieldactualchange },
                |m: &mut VectorFloat| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorFloat>(
                "VectorFloat",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorFloat {
        static instance: ::protobuf::rt::LazyV2<VectorFloat> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorFloat::new)
    }
}

impl ::protobuf::Clear for VectorFloat {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorFloat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorFloat {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VectorDouble {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    pub val: ::std::vec::Vec<f64>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VectorDouble {
    fn default() -> &'a VectorDouble {
        <VectorDouble as ::protobuf::Message>::default_instance()
    }
}

impl VectorDouble {
    pub fn new() -> VectorDouble {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // repeated double val = 3;


    pub fn get_val(&self) -> &[f64] {
        &self.val
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<f64>) {
        self.val = v;
    }

    // Mutable pointer to the field.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.val
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.val, ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VectorDouble {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.val.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.val.len() * 8) as u32) + (self.val.len() * 8) as u32;
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if !self.val.is_empty() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.val.len() * 8) as u32)?;
            for v in &self.val {
                os.write_double_no_tag(*v)?;
            };
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VectorDouble {
        VectorDouble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &VectorDouble| { &m.secondsintoyear },
                |m: &mut VectorDouble| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &VectorDouble| { &m.nano },
                |m: &mut VectorDouble| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "val",
                |m: &VectorDouble| { &m.val },
                |m: &mut VectorDouble| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &VectorDouble| { &m.severity },
                |m: &mut VectorDouble| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &VectorDouble| { &m.status },
                |m: &mut VectorDouble| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &VectorDouble| { &m.repeatcount },
                |m: &mut VectorDouble| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &VectorDouble| { &m.fieldvalues },
                |m: &mut VectorDouble| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &VectorDouble| { &m.fieldactualchange },
                |m: &mut VectorDouble| { &mut m.fieldactualchange },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VectorDouble>(
                "VectorDouble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VectorDouble {
        static instance: ::protobuf::rt::LazyV2<VectorDouble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VectorDouble::new)
    }
}

impl ::protobuf::Clear for VectorDouble {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VectorDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VectorDouble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct V4GenericBytes {
    // message fields
    secondsintoyear: ::std::option::Option<u32>,
    nano: ::std::option::Option<u32>,
    val: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    severity: ::std::option::Option<i32>,
    status: ::std::option::Option<i32>,
    repeatcount: ::std::option::Option<u32>,
    pub fieldvalues: ::protobuf::RepeatedField<FieldValue>,
    fieldactualchange: ::std::option::Option<bool>,
    userTag: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a V4GenericBytes {
    fn default() -> &'a V4GenericBytes {
        <V4GenericBytes as ::protobuf::Message>::default_instance()
    }
}

impl V4GenericBytes {
    pub fn new() -> V4GenericBytes {
        ::std::default::Default::default()
    }

    // required uint32 secondsintoyear = 1;


    pub fn get_secondsintoyear(&self) -> u32 {
        self.secondsintoyear.unwrap_or(0)
    }
    pub fn clear_secondsintoyear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
    }

    pub fn has_secondsintoyear(&self) -> bool {
        self.secondsintoyear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secondsintoyear(&mut self, v: u32) {
        self.secondsintoyear = ::std::option::Option::Some(v);
    }

    // required uint32 nano = 2;


    pub fn get_nano(&self) -> u32 {
        self.nano.unwrap_or(0)
    }
    pub fn clear_nano(&mut self) {
        self.nano = ::std::option::Option::None;
    }

    pub fn has_nano(&self) -> bool {
        self.nano.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nano(&mut self, v: u32) {
        self.nano = ::std::option::Option::Some(v);
    }

    // required bytes val = 3;


    pub fn get_val(&self) -> &[u8] {
        match self.val.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_val(&mut self) {
        self.val.clear();
    }

    pub fn has_val(&self) -> bool {
        self.val.is_some()
    }

    // Param is passed by value, moved
    pub fn set_val(&mut self, v: ::std::vec::Vec<u8>) {
        self.val = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_val(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.val.is_none() {
            self.val.set_default();
        }
        self.val.as_mut().unwrap()
    }

    // Take field
    pub fn take_val(&mut self) -> ::std::vec::Vec<u8> {
        self.val.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional int32 severity = 4;


    pub fn get_severity(&self) -> i32 {
        self.severity.unwrap_or(0i32)
    }
    pub fn clear_severity(&mut self) {
        self.severity = ::std::option::Option::None;
    }

    pub fn has_severity(&self) -> bool {
        self.severity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_severity(&mut self, v: i32) {
        self.severity = ::std::option::Option::Some(v);
    }

    // optional int32 status = 5;


    pub fn get_status(&self) -> i32 {
        self.status.unwrap_or(0i32)
    }
    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 repeatcount = 6;


    pub fn get_repeatcount(&self) -> u32 {
        self.repeatcount.unwrap_or(0)
    }
    pub fn clear_repeatcount(&mut self) {
        self.repeatcount = ::std::option::Option::None;
    }

    pub fn has_repeatcount(&self) -> bool {
        self.repeatcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repeatcount(&mut self, v: u32) {
        self.repeatcount = ::std::option::Option::Some(v);
    }

    // repeated .EPICS.FieldValue fieldvalues = 7;


    pub fn get_fieldvalues(&self) -> &[FieldValue] {
        &self.fieldvalues
    }
    pub fn clear_fieldvalues(&mut self) {
        self.fieldvalues.clear();
    }

    // Param is passed by value, moved
    pub fn set_fieldvalues(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.fieldvalues = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fieldvalues(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.fieldvalues
    }

    // Take field
    pub fn take_fieldvalues(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.fieldvalues, ::protobuf::RepeatedField::new())
    }

    // optional bool fieldactualchange = 8;


    pub fn get_fieldactualchange(&self) -> bool {
        self.fieldactualchange.unwrap_or(false)
    }
    pub fn clear_fieldactualchange(&mut self) {
        self.fieldactualchange = ::std::option::Option::None;
    }

    pub fn has_fieldactualchange(&self) -> bool {
        self.fieldactualchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldactualchange(&mut self, v: bool) {
        self.fieldactualchange = ::std::option::Option::Some(v);
    }

    // optional uint32 userTag = 9;


    pub fn get_userTag(&self) -> u32 {
        self.userTag.unwrap_or(0)
    }
    pub fn clear_userTag(&mut self) {
        self.userTag = ::std::option::Option::None;
    }

    pub fn has_userTag(&self) -> bool {
        self.userTag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userTag(&mut self, v: u32) {
        self.userTag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for V4GenericBytes {
    fn is_initialized(&self) -> bool {
        if self.secondsintoyear.is_none() {
            return false;
        }
        if self.nano.is_none() {
            return false;
        }
        if self.val.is_none() {
            return false;
        }
        for v in &self.fieldvalues {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.secondsintoyear = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.nano = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.val)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.severity = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.repeatcount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fieldvalues)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fieldactualchange = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.userTag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.secondsintoyear {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nano {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.val.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.severity {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.status {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.repeatcount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.fieldvalues {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.fieldactualchange {
            my_size += 2;
        }
        if let Some(v) = self.userTag {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.secondsintoyear {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.nano {
            os.write_uint32(2, v)?;
        }
        if let Some(ref v) = self.val.as_ref() {
            os.write_bytes(3, &v)?;
        }
        if let Some(v) = self.severity {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.repeatcount {
            os.write_uint32(6, v)?;
        }
        for v in &self.fieldvalues {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.fieldactualchange {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.userTag {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> V4GenericBytes {
        V4GenericBytes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "secondsintoyear",
                |m: &V4GenericBytes| { &m.secondsintoyear },
                |m: &mut V4GenericBytes| { &mut m.secondsintoyear },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "nano",
                |m: &V4GenericBytes| { &m.nano },
                |m: &mut V4GenericBytes| { &mut m.nano },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "val",
                |m: &V4GenericBytes| { &m.val },
                |m: &mut V4GenericBytes| { &mut m.val },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "severity",
                |m: &V4GenericBytes| { &m.severity },
                |m: &mut V4GenericBytes| { &mut m.severity },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "status",
                |m: &V4GenericBytes| { &m.status },
                |m: &mut V4GenericBytes| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "repeatcount",
                |m: &V4GenericBytes| { &m.repeatcount },
                |m: &mut V4GenericBytes| { &mut m.repeatcount },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "fieldvalues",
                |m: &V4GenericBytes| { &m.fieldvalues },
                |m: &mut V4GenericBytes| { &mut m.fieldvalues },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fieldactualchange",
                |m: &V4GenericBytes| { &m.fieldactualchange },
                |m: &mut V4GenericBytes| { &mut m.fieldactualchange },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "userTag",
                |m: &V4GenericBytes| { &m.userTag },
                |m: &mut V4GenericBytes| { &mut m.userTag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<V4GenericBytes>(
                "V4GenericBytes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static V4GenericBytes {
        static instance: ::protobuf::rt::LazyV2<V4GenericBytes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(V4GenericBytes::new)
    }
}

impl ::protobuf::Clear for V4GenericBytes {
    fn clear(&mut self) {
        self.secondsintoyear = ::std::option::Option::None;
        self.nano = ::std::option::Option::None;
        self.val.clear();
        self.severity = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.repeatcount = ::std::option::Option::None;
        self.fieldvalues.clear();
        self.fieldactualchange = ::std::option::Option::None;
        self.userTag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for V4GenericBytes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for V4GenericBytes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PayloadInfo {
    // message fields
    field_type: ::std::option::Option<PayloadType>,
    pvname: ::protobuf::SingularField<::std::string::String>,
    year: ::std::option::Option<i32>,
    elementCount: ::std::option::Option<i32>,
    unused00: ::std::option::Option<f64>,
    unused01: ::std::option::Option<f64>,
    unused02: ::std::option::Option<f64>,
    unused03: ::std::option::Option<f64>,
    unused04: ::std::option::Option<f64>,
    unused05: ::std::option::Option<f64>,
    unused06: ::std::option::Option<f64>,
    unused07: ::std::option::Option<f64>,
    unused08: ::std::option::Option<f64>,
    unused09: ::protobuf::SingularField<::std::string::String>,
    pub headers: ::protobuf::RepeatedField<FieldValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PayloadInfo {
    fn default() -> &'a PayloadInfo {
        <PayloadInfo as ::protobuf::Message>::default_instance()
    }
}

impl PayloadInfo {
    pub fn new() -> PayloadInfo {
        ::std::default::Default::default()
    }

    // required .EPICS.PayloadType type = 1;


    pub fn get_field_type(&self) -> PayloadType {
        self.field_type.unwrap_or(PayloadType::SCALAR_STRING)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: PayloadType) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // required string pvname = 2;


    pub fn get_pvname(&self) -> &str {
        match self.pvname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pvname(&mut self) {
        self.pvname.clear();
    }

    pub fn has_pvname(&self) -> bool {
        self.pvname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pvname(&mut self, v: ::std::string::String) {
        self.pvname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pvname(&mut self) -> &mut ::std::string::String {
        if self.pvname.is_none() {
            self.pvname.set_default();
        }
        self.pvname.as_mut().unwrap()
    }

    // Take field
    pub fn take_pvname(&mut self) -> ::std::string::String {
        self.pvname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 year = 3;


    pub fn get_year(&self) -> i32 {
        self.year.unwrap_or(0)
    }
    pub fn clear_year(&mut self) {
        self.year = ::std::option::Option::None;
    }

    pub fn has_year(&self) -> bool {
        self.year.is_some()
    }

    // Param is passed by value, moved
    pub fn set_year(&mut self, v: i32) {
        self.year = ::std::option::Option::Some(v);
    }

    // optional int32 elementCount = 4;


    pub fn get_elementCount(&self) -> i32 {
        self.elementCount.unwrap_or(0)
    }
    pub fn clear_elementCount(&mut self) {
        self.elementCount = ::std::option::Option::None;
    }

    pub fn has_elementCount(&self) -> bool {
        self.elementCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elementCount(&mut self, v: i32) {
        self.elementCount = ::std::option::Option::Some(v);
    }

    // optional double unused00 = 5;


    pub fn get_unused00(&self) -> f64 {
        self.unused00.unwrap_or(0.)
    }
    pub fn clear_unused00(&mut self) {
        self.unused00 = ::std::option::Option::None;
    }

    pub fn has_unused00(&self) -> bool {
        self.unused00.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused00(&mut self, v: f64) {
        self.unused00 = ::std::option::Option::Some(v);
    }

    // optional double unused01 = 6;


    pub fn get_unused01(&self) -> f64 {
        self.unused01.unwrap_or(0.)
    }
    pub fn clear_unused01(&mut self) {
        self.unused01 = ::std::option::Option::None;
    }

    pub fn has_unused01(&self) -> bool {
        self.unused01.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused01(&mut self, v: f64) {
        self.unused01 = ::std::option::Option::Some(v);
    }

    // optional double unused02 = 7;


    pub fn get_unused02(&self) -> f64 {
        self.unused02.unwrap_or(0.)
    }
    pub fn clear_unused02(&mut self) {
        self.unused02 = ::std::option::Option::None;
    }

    pub fn has_unused02(&self) -> bool {
        self.unused02.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused02(&mut self, v: f64) {
        self.unused02 = ::std::option::Option::Some(v);
    }

    // optional double unused03 = 8;


    pub fn get_unused03(&self) -> f64 {
        self.unused03.unwrap_or(0.)
    }
    pub fn clear_unused03(&mut self) {
        self.unused03 = ::std::option::Option::None;
    }

    pub fn has_unused03(&self) -> bool {
        self.unused03.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused03(&mut self, v: f64) {
        self.unused03 = ::std::option::Option::Some(v);
    }

    // optional double unused04 = 9;


    pub fn get_unused04(&self) -> f64 {
        self.unused04.unwrap_or(0.)
    }
    pub fn clear_unused04(&mut self) {
        self.unused04 = ::std::option::Option::None;
    }

    pub fn has_unused04(&self) -> bool {
        self.unused04.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused04(&mut self, v: f64) {
        self.unused04 = ::std::option::Option::Some(v);
    }

    // optional double unused05 = 10;


    pub fn get_unused05(&self) -> f64 {
        self.unused05.unwrap_or(0.)
    }
    pub fn clear_unused05(&mut self) {
        self.unused05 = ::std::option::Option::None;
    }

    pub fn has_unused05(&self) -> bool {
        self.unused05.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused05(&mut self, v: f64) {
        self.unused05 = ::std::option::Option::Some(v);
    }

    // optional double unused06 = 11;


    pub fn get_unused06(&self) -> f64 {
        self.unused06.unwrap_or(0.)
    }
    pub fn clear_unused06(&mut self) {
        self.unused06 = ::std::option::Option::None;
    }

    pub fn has_unused06(&self) -> bool {
        self.unused06.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused06(&mut self, v: f64) {
        self.unused06 = ::std::option::Option::Some(v);
    }

    // optional double unused07 = 12;


    pub fn get_unused07(&self) -> f64 {
        self.unused07.unwrap_or(0.)
    }
    pub fn clear_unused07(&mut self) {
        self.unused07 = ::std::option::Option::None;
    }

    pub fn has_unused07(&self) -> bool {
        self.unused07.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused07(&mut self, v: f64) {
        self.unused07 = ::std::option::Option::Some(v);
    }

    // optional double unused08 = 13;


    pub fn get_unused08(&self) -> f64 {
        self.unused08.unwrap_or(0.)
    }
    pub fn clear_unused08(&mut self) {
        self.unused08 = ::std::option::Option::None;
    }

    pub fn has_unused08(&self) -> bool {
        self.unused08.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused08(&mut self, v: f64) {
        self.unused08 = ::std::option::Option::Some(v);
    }

    // optional string unused09 = 14;


    pub fn get_unused09(&self) -> &str {
        match self.unused09.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_unused09(&mut self) {
        self.unused09.clear();
    }

    pub fn has_unused09(&self) -> bool {
        self.unused09.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unused09(&mut self, v: ::std::string::String) {
        self.unused09 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unused09(&mut self) -> &mut ::std::string::String {
        if self.unused09.is_none() {
            self.unused09.set_default();
        }
        self.unused09.as_mut().unwrap()
    }

    // Take field
    pub fn take_unused09(&mut self) -> ::std::string::String {
        self.unused09.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .EPICS.FieldValue headers = 15;


    pub fn get_headers(&self) -> &[FieldValue] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<FieldValue>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<FieldValue> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<FieldValue> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PayloadInfo {
    fn is_initialized(&self) -> bool {
        if self.field_type.is_none() {
            return false;
        }
        if self.pvname.is_none() {
            return false;
        }
        if self.year.is_none() {
            return false;
        }
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pvname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.year = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.elementCount = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused00 = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused01 = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused02 = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused03 = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused04 = ::std::option::Option::Some(tmp);
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused05 = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused06 = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused07 = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.unused08 = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.unused09)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::enum_size(1, v);
        }
        if let Some(ref v) = self.pvname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.year {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.elementCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.unused00 {
            my_size += 9;
        }
        if let Some(v) = self.unused01 {
            my_size += 9;
        }
        if let Some(v) = self.unused02 {
            my_size += 9;
        }
        if let Some(v) = self.unused03 {
            my_size += 9;
        }
        if let Some(v) = self.unused04 {
            my_size += 9;
        }
        if let Some(v) = self.unused05 {
            my_size += 9;
        }
        if let Some(v) = self.unused06 {
            my_size += 9;
        }
        if let Some(v) = self.unused07 {
            my_size += 9;
        }
        if let Some(v) = self.unused08 {
            my_size += 9;
        }
        if let Some(ref v) = self.unused09.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.field_type {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(ref v) = self.pvname.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.year {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.elementCount {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.unused00 {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.unused01 {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.unused02 {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.unused03 {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.unused04 {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.unused05 {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.unused06 {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.unused07 {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.unused08 {
            os.write_double(13, v)?;
        }
        if let Some(ref v) = self.unused09.as_ref() {
            os.write_string(14, &v)?;
        }
        for v in &self.headers {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PayloadInfo {
        PayloadInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PayloadType>>(
                "type",
                |m: &PayloadInfo| { &m.field_type },
                |m: &mut PayloadInfo| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pvname",
                |m: &PayloadInfo| { &m.pvname },
                |m: &mut PayloadInfo| { &mut m.pvname },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "year",
                |m: &PayloadInfo| { &m.year },
                |m: &mut PayloadInfo| { &mut m.year },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "elementCount",
                |m: &PayloadInfo| { &m.elementCount },
                |m: &mut PayloadInfo| { &mut m.elementCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused00",
                |m: &PayloadInfo| { &m.unused00 },
                |m: &mut PayloadInfo| { &mut m.unused00 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused01",
                |m: &PayloadInfo| { &m.unused01 },
                |m: &mut PayloadInfo| { &mut m.unused01 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused02",
                |m: &PayloadInfo| { &m.unused02 },
                |m: &mut PayloadInfo| { &mut m.unused02 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused03",
                |m: &PayloadInfo| { &m.unused03 },
                |m: &mut PayloadInfo| { &mut m.unused03 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused04",
                |m: &PayloadInfo| { &m.unused04 },
                |m: &mut PayloadInfo| { &mut m.unused04 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused05",
                |m: &PayloadInfo| { &m.unused05 },
                |m: &mut PayloadInfo| { &mut m.unused05 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused06",
                |m: &PayloadInfo| { &m.unused06 },
                |m: &mut PayloadInfo| { &mut m.unused06 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused07",
                |m: &PayloadInfo| { &m.unused07 },
                |m: &mut PayloadInfo| { &mut m.unused07 },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "unused08",
                |m: &PayloadInfo| { &m.unused08 },
                |m: &mut PayloadInfo| { &mut m.unused08 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unused09",
                |m: &PayloadInfo| { &m.unused09 },
                |m: &mut PayloadInfo| { &mut m.unused09 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldValue>>(
                "headers",
                |m: &PayloadInfo| { &m.headers },
                |m: &mut PayloadInfo| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PayloadInfo>(
                "PayloadInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PayloadInfo {
        static instance: ::protobuf::rt::LazyV2<PayloadInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PayloadInfo::new)
    }
}

impl ::protobuf::Clear for PayloadInfo {
    fn clear(&mut self) {
        self.field_type = ::std::option::Option::None;
        self.pvname.clear();
        self.year = ::std::option::Option::None;
        self.elementCount = ::std::option::Option::None;
        self.unused00 = ::std::option::Option::None;
        self.unused01 = ::std::option::Option::None;
        self.unused02 = ::std::option::Option::None;
        self.unused03 = ::std::option::Option::None;
        self.unused04 = ::std::option::Option::None;
        self.unused05 = ::std::option::Option::None;
        self.unused06 = ::std::option::Option::None;
        self.unused07 = ::std::option::Option::None;
        self.unused08 = ::std::option::Option::None;
        self.unused09.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PayloadInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PayloadInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PayloadType {
    SCALAR_STRING = 0,
    SCALAR_SHORT = 1,
    SCALAR_FLOAT = 2,
    SCALAR_ENUM = 3,
    SCALAR_BYTE = 4,
    SCALAR_INT = 5,
    SCALAR_DOUBLE = 6,
    WAVEFORM_STRING = 7,
    WAVEFORM_SHORT = 8,
    WAVEFORM_FLOAT = 9,
    WAVEFORM_ENUM = 10,
    WAVEFORM_BYTE = 11,
    WAVEFORM_INT = 12,
    WAVEFORM_DOUBLE = 13,
    V4_GENERIC_BYTES = 14,
}

impl ::protobuf::ProtobufEnum for PayloadType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PayloadType> {
        match value {
            0 => ::std::option::Option::Some(PayloadType::SCALAR_STRING),
            1 => ::std::option::Option::Some(PayloadType::SCALAR_SHORT),
            2 => ::std::option::Option::Some(PayloadType::SCALAR_FLOAT),
            3 => ::std::option::Option::Some(PayloadType::SCALAR_ENUM),
            4 => ::std::option::Option::Some(PayloadType::SCALAR_BYTE),
            5 => ::std::option::Option::Some(PayloadType::SCALAR_INT),
            6 => ::std::option::Option::Some(PayloadType::SCALAR_DOUBLE),
            7 => ::std::option::Option::Some(PayloadType::WAVEFORM_STRING),
            8 => ::std::option::Option::Some(PayloadType::WAVEFORM_SHORT),
            9 => ::std::option::Option::Some(PayloadType::WAVEFORM_FLOAT),
            10 => ::std::option::Option::Some(PayloadType::WAVEFORM_ENUM),
            11 => ::std::option::Option::Some(PayloadType::WAVEFORM_BYTE),
            12 => ::std::option::Option::Some(PayloadType::WAVEFORM_INT),
            13 => ::std::option::Option::Some(PayloadType::WAVEFORM_DOUBLE),
            14 => ::std::option::Option::Some(PayloadType::V4_GENERIC_BYTES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PayloadType] = &[
            PayloadType::SCALAR_STRING,
            PayloadType::SCALAR_SHORT,
            PayloadType::SCALAR_FLOAT,
            PayloadType::SCALAR_ENUM,
            PayloadType::SCALAR_BYTE,
            PayloadType::SCALAR_INT,
            PayloadType::SCALAR_DOUBLE,
            PayloadType::WAVEFORM_STRING,
            PayloadType::WAVEFORM_SHORT,
            PayloadType::WAVEFORM_FLOAT,
            PayloadType::WAVEFORM_ENUM,
            PayloadType::WAVEFORM_BYTE,
            PayloadType::WAVEFORM_INT,
            PayloadType::WAVEFORM_DOUBLE,
            PayloadType::V4_GENERIC_BYTES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PayloadType>("PayloadType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PayloadType {
}

impl ::std::default::Default for PayloadType {
    fn default() -> Self {
        PayloadType::SCALAR_STRING
    }
}

impl ::protobuf::reflect::ProtobufValue for PayloadType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10EPICSEvent.proto\x12\x05EPICS\"2\n\nFieldValue\x12\x12\n\x04name\
    \x18\x01\x20\x02(\tR\x04name\x12\x10\n\x03val\x18\x02\x20\x02(\tR\x03val\
    \"\x9d\x02\n\x0cScalarString\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\
    \rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\
    \x10\n\x03val\x18\x03\x20\x02(\tR\x03val\x12\x1d\n\x08severity\x18\x04\
    \x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\x20\x01(\
    \x05:\x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0bre\
    peatcount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldVal\
    ueR\x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\x08R\x11\
    fieldactualchange\"\x9b\x02\n\nScalarByte\x12(\n\x0fsecondsintoyear\x18\
    \x01\x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\r\
    R\x04nano\x12\x10\n\x03val\x18\x03\x20\x02(\x0cR\x03val\x12\x1d\n\x08sev\
    erity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\
    \x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\
    \x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.\
    EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\
    \x01(\x08R\x11fieldactualchange\"\x9c\x02\n\x0bScalarShort\x12(\n\x0fsec\
    ondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\
    \x18\x02\x20\x02(\rR\x04nano\x12\x10\n\x03val\x18\x03\x20\x02(\x11R\x03v\
    al\x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\
    \n\x06status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatco\
    unt\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\
    \x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualcha\
    nge\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\x9a\x02\n\tScalarInt\
    \x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\
    \x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x10\n\x03val\x18\x03\x20\
    \x02(\x0fR\x03val\x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08s\
    everity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\
    \x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfield\
    values\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\
    \x11fieldactualchange\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\x9b\
    \x02\n\nScalarEnum\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fseco\
    ndsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x10\n\x03v\
    al\x18\x03\x20\x02(\x11R\x03val\x12\x1d\n\x08severity\x18\x04\x20\x01(\
    \x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\
    \x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\
    \x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfi\
    eldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\x08R\x11fieldactu\
    alchange\"\x9c\x02\n\x0bScalarFloat\x12(\n\x0fsecondsintoyear\x18\x01\
    \x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\
    \x04nano\x12\x10\n\x03val\x18\x03\x20\x02(\x02R\x03val\x12\x1d\n\x08seve\
    rity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\
    \x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\
    \rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS\
    .FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\
    \x08R\x11fieldactualchange\"\x9d\x02\n\x0cScalarDouble\x12(\n\x0fseconds\
    intoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\
    \x02\x20\x02(\rR\x04nano\x12\x10\n\x03val\x18\x03\x20\x02(\x01R\x03val\
    \x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\
    \x06status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcoun\
    t\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\
    \x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualcha\
    nge\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\x9d\x02\n\x0cVectorStri\
    ng\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\
    \x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x10\n\x03val\x18\x03\x20\
    \x03(\tR\x03val\x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08sev\
    erity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\x20\
    \n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfieldvalu\
    es\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11\
    fieldactualchange\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\x9b\x02\n\
    \nVectorChar\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsint\
    oyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x10\n\x03val\x18\
    \x03\x20\x02(\x0cR\x03val\x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\
    \x010R\x08severity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\x06st\
    atus\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\
    \x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalu\
    es\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\x08R\x11fieldactualchang\
    e\"\xa0\x02\n\x0bVectorShort\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\
    \rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\
    \x14\n\x03val\x18\x03\x20\x03(\x11R\x03valB\x02\x10\x01\x12\x1d\n\x08sev\
    erity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\
    \x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\
    \x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.\
    EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\
    \x01(\x08R\x11fieldactualchange\"\x9e\x02\n\tVectorInt\x12(\n\x0fseconds\
    intoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\
    \x02\x20\x02(\rR\x04nano\x12\x14\n\x03val\x18\x03\x20\x03(\x0fR\x03valB\
    \x02\x10\x01\x12\x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08severi\
    ty\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\
    \x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\
    \x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fi\
    eldactualchange\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\x9f\x02\n\n\
    VectorEnum\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsintoy\
    ear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x14\n\x03val\x18\
    \x03\x20\x03(\x11R\x03valB\x02\x10\x01\x12\x1d\n\x08severity\x18\x04\x20\
    \x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\
    \x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatc\
    ount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\
    \x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\x08R\x11fie\
    ldactualchange\"\xa0\x02\n\x0bVectorFloat\x12(\n\x0fsecondsintoyear\x18\
    \x01\x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\r\
    R\x04nano\x12\x14\n\x03val\x18\x03\x20\x03(\x02R\x03valB\x02\x10\x01\x12\
    \x1d\n\x08severity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06\
    status\x18\x05\x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcount\
    \x18\x06\x20\x01(\rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\
    \x03(\x0b2\x11.EPICS.FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualcha\
    nge\x18\x08\x20\x01(\x08R\x11fieldactualchange\"\xa1\x02\n\x0cVectorDoub\
    le\x12(\n\x0fsecondsintoyear\x18\x01\x20\x02(\rR\x0fsecondsintoyear\x12\
    \x12\n\x04nano\x18\x02\x20\x02(\rR\x04nano\x12\x14\n\x03val\x18\x03\x20\
    \x03(\x01R\x03valB\x02\x10\x01\x12\x1d\n\x08severity\x18\x04\x20\x01(\
    \x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\x20\x01(\x05:\x010R\
    \x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\rR\x0brepeatcount\
    \x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS.FieldValueR\x0bfi\
    eldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\x08R\x11fieldactu\
    alchange\"\xb9\x02\n\x0eV4GenericBytes\x12(\n\x0fsecondsintoyear\x18\x01\
    \x20\x02(\rR\x0fsecondsintoyear\x12\x12\n\x04nano\x18\x02\x20\x02(\rR\
    \x04nano\x12\x10\n\x03val\x18\x03\x20\x02(\x0cR\x03val\x12\x1d\n\x08seve\
    rity\x18\x04\x20\x01(\x05:\x010R\x08severity\x12\x19\n\x06status\x18\x05\
    \x20\x01(\x05:\x010R\x06status\x12\x20\n\x0brepeatcount\x18\x06\x20\x01(\
    \rR\x0brepeatcount\x123\n\x0bfieldvalues\x18\x07\x20\x03(\x0b2\x11.EPICS\
    .FieldValueR\x0bfieldvalues\x12,\n\x11fieldactualchange\x18\x08\x20\x01(\
    \x08R\x11fieldactualchange\x12\x18\n\x07userTag\x18\t\x20\x01(\rR\x07use\
    rTag\"\xca\x03\n\x0bPayloadInfo\x12&\n\x04type\x18\x01\x20\x02(\x0e2\x12\
    .EPICS.PayloadTypeR\x04type\x12\x16\n\x06pvname\x18\x02\x20\x02(\tR\x06p\
    vname\x12\x12\n\x04year\x18\x03\x20\x02(\x05R\x04year\x12\"\n\x0celement\
    Count\x18\x04\x20\x01(\x05R\x0celementCount\x12\x1a\n\x08unused00\x18\
    \x05\x20\x01(\x01R\x08unused00\x12\x1a\n\x08unused01\x18\x06\x20\x01(\
    \x01R\x08unused01\x12\x1a\n\x08unused02\x18\x07\x20\x01(\x01R\x08unused0\
    2\x12\x1a\n\x08unused03\x18\x08\x20\x01(\x01R\x08unused03\x12\x1a\n\x08u\
    nused04\x18\t\x20\x01(\x01R\x08unused04\x12\x1a\n\x08unused05\x18\n\x20\
    \x01(\x01R\x08unused05\x12\x1a\n\x08unused06\x18\x0b\x20\x01(\x01R\x08un\
    used06\x12\x1a\n\x08unused07\x18\x0c\x20\x01(\x01R\x08unused07\x12\x1a\n\
    \x08unused08\x18\r\x20\x01(\x01R\x08unused08\x12\x1a\n\x08unused09\x18\
    \x0e\x20\x01(\tR\x08unused09\x12+\n\x07headers\x18\x0f\x20\x03(\x0b2\x11\
    .EPICS.FieldValueR\x07headers*\xa9\x02\n\x0bPayloadType\x12\x11\n\rSCALA\
    R_STRING\x10\0\x12\x10\n\x0cSCALAR_SHORT\x10\x01\x12\x10\n\x0cSCALAR_FLO\
    AT\x10\x02\x12\x0f\n\x0bSCALAR_ENUM\x10\x03\x12\x0f\n\x0bSCALAR_BYTE\x10\
    \x04\x12\x0e\n\nSCALAR_INT\x10\x05\x12\x11\n\rSCALAR_DOUBLE\x10\x06\x12\
    \x13\n\x0fWAVEFORM_STRING\x10\x07\x12\x12\n\x0eWAVEFORM_SHORT\x10\x08\
    \x12\x12\n\x0eWAVEFORM_FLOAT\x10\t\x12\x11\n\rWAVEFORM_ENUM\x10\n\x12\
    \x11\n\rWAVEFORM_BYTE\x10\x0b\x12\x10\n\x0cWAVEFORM_INT\x10\x0c\x12\x13\
    \n\x0fWAVEFORM_DOUBLE\x10\r\x12\x14\n\x10V4_GENERIC_BYTES\x10\x0eB4\n&ed\
    u.stanford.slac.archiverappliance.PBB\nEPICSEventJ\xa5i\n\x07\x12\x05\0\
    \0\xe3\x01\x01\n\x08\n\x01\x02\x12\x03\0\x08\r\n\x08\n\x01\x08\x12\x03\
    \x02\0?\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x02\0?\n\x0c\n\x05\x08\xe7\x07\
    \0\x02\x12\x03\x02\x07\x13\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x02\x07\
    \x13\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x02\x07\x13\n\x0c\n\x05\
    \x08\xe7\x07\0\x07\x12\x03\x02\x16>\n\x08\n\x01\x08\x12\x03\x03\0+\n\x0b\
    \n\x04\x08\xe7\x07\x01\x12\x03\x03\0+\n\x0c\n\x05\x08\xe7\x07\x01\x02\
    \x12\x03\x03\x07\x1b\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x03\x07\x1b\
    \n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x03\x07\x1b\n\x0c\n\x05\
    \x08\xe7\x07\x01\x07\x12\x03\x03\x1e*\n\n\n\x02\x04\0\x12\x04\x05\0\x08\
    \x01\n\n\n\x03\x04\0\x01\x12\x03\x05\x08\x12\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03\x06\x08!\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\x06\x08\x10\n\x0c\n\
    \x05\x04\0\x02\0\x05\x12\x03\x06\x11\x17\n\x0c\n\x05\x04\0\x02\0\x01\x12\
    \x03\x06\x18\x1c\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\x06\x1f\x20\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03\x07\x08\x20\n\x0c\n\x05\x04\0\x02\x01\x04\x12\
    \x03\x07\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x07\x11\x17\n\x0c\
    \n\x05\x04\0\x02\x01\x01\x12\x03\x07\x18\x1b\n\x0c\n\x05\x04\0\x02\x01\
    \x03\x12\x03\x07\x1e\x1f\n\n\n\x02\x04\x01\x12\x04\n\0\x13\x01\n\n\n\x03\
    \x04\x01\x01\x12\x03\n\x08\x14\n\x0b\n\x04\x04\x01\x02\0\x12\x03\x0b\x02\
    &\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\x0b\x02\n\n\x0c\n\x05\x04\x01\
    \x02\0\x05\x12\x03\x0b\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x0b\
    \x12!\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03\x0b$%\n\x0b\n\x04\x04\x01\
    \x02\x01\x12\x03\x0c\x02\x1b\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03\x0c\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03\x0c\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03\x0c\x12\x16\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03\x0c\x19\x1a\n\x0b\n\x04\x04\x01\x02\x02\x12\x03\r\x02\x1a\n\x0c\
    \n\x05\x04\x01\x02\x02\x04\x12\x03\r\x02\n\n\x0c\n\x05\x04\x01\x02\x02\
    \x05\x12\x03\r\x0b\x11\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03\r\x12\x15\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03\r\x18\x19\n\x0b\n\x04\x04\x01\
    \x02\x03\x12\x03\x0e\x02,\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03\x0e\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03\x0e\x0b\x10\n\x0c\n\x05\
    \x04\x01\x02\x03\x01\x12\x03\x0e\x11\x19\n\x0c\n\x05\x04\x01\x02\x03\x03\
    \x12\x03\x0e\x1c\x1d\n\x0c\n\x05\x04\x01\x02\x03\x08\x12\x03\x0e\x1e+\n\
    \x0c\n\x05\x04\x01\x02\x03\x07\x12\x03\x0e)*\n\x0b\n\x04\x04\x01\x02\x04\
    \x12\x03\x0f\x02*\n\x0c\n\x05\x04\x01\x02\x04\x04\x12\x03\x0f\x02\n\n\
    \x0c\n\x05\x04\x01\x02\x04\x05\x12\x03\x0f\x0b\x10\n\x0c\n\x05\x04\x01\
    \x02\x04\x01\x12\x03\x0f\x11\x17\n\x0c\n\x05\x04\x01\x02\x04\x03\x12\x03\
    \x0f\x1a\x1b\n\x0c\n\x05\x04\x01\x02\x04\x08\x12\x03\x0f\x1c)\n\x0c\n\
    \x05\x04\x01\x02\x04\x07\x12\x03\x0f'(\n\x0b\n\x04\x04\x01\x02\x05\x12\
    \x03\x10\x02\"\n\x0c\n\x05\x04\x01\x02\x05\x04\x12\x03\x10\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x05\x05\x12\x03\x10\x0b\x11\n\x0c\n\x05\x04\x01\x02\x05\
    \x01\x12\x03\x10\x12\x1d\n\x0c\n\x05\x04\x01\x02\x05\x03\x12\x03\x10\x20\
    !\n\x0b\n\x04\x04\x01\x02\x06\x12\x03\x11\x02&\n\x0c\n\x05\x04\x01\x02\
    \x06\x04\x12\x03\x11\x02\n\n\x0c\n\x05\x04\x01\x02\x06\x06\x12\x03\x11\
    \x0b\x15\n\x0c\n\x05\x04\x01\x02\x06\x01\x12\x03\x11\x16!\n\x0c\n\x05\
    \x04\x01\x02\x06\x03\x12\x03\x11$%\n\x0b\n\x04\x04\x01\x02\x07\x12\x03\
    \x12\x02&\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\x03\x12\x02\n\n\x0c\n\x05\
    \x04\x01\x02\x07\x05\x12\x03\x12\x0b\x0f\n\x0c\n\x05\x04\x01\x02\x07\x01\
    \x12\x03\x12\x10!\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\x12$%\n\n\n\
    \x02\x04\x02\x12\x04\x15\0\x1e\x01\n\n\n\x03\x04\x02\x01\x12\x03\x15\x08\
    \x12\n\x0b\n\x04\x04\x02\x02\0\x12\x03\x16\x02&\n\x0c\n\x05\x04\x02\x02\
    \0\x04\x12\x03\x16\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03\x16\x0b\
    \x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03\x16\x12!\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03\x16$%\n\x0b\n\x04\x04\x02\x02\x01\x12\x03\x17\x02\x1b\
    \n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03\x17\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x01\x05\x12\x03\x17\x0b\x11\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03\
    \x17\x12\x16\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03\x17\x19\x1a\n\x0b\n\
    \x04\x04\x02\x02\x02\x12\x03\x18\x02\x19\n\x0c\n\x05\x04\x02\x02\x02\x04\
    \x12\x03\x18\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03\x18\x0b\x10\n\
    \x0c\n\x05\x04\x02\x02\x02\x01\x12\x03\x18\x11\x14\n\x0c\n\x05\x04\x02\
    \x02\x02\x03\x12\x03\x18\x17\x18\n\x0b\n\x04\x04\x02\x02\x03\x12\x03\x19\
    \x02,\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03\x19\x02\n\n\x0c\n\x05\x04\
    \x02\x02\x03\x05\x12\x03\x19\x0b\x10\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\
    \x03\x19\x11\x19\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03\x19\x1c\x1d\n\
    \x0c\n\x05\x04\x02\x02\x03\x08\x12\x03\x19\x1e+\n\x0c\n\x05\x04\x02\x02\
    \x03\x07\x12\x03\x19)*\n\x0b\n\x04\x04\x02\x02\x04\x12\x03\x1a\x02*\n\
    \x0c\n\x05\x04\x02\x02\x04\x04\x12\x03\x1a\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x04\x05\x12\x03\x1a\x0b\x10\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03\x1a\
    \x11\x17\n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03\x1a\x1a\x1b\n\x0c\n\x05\
    \x04\x02\x02\x04\x08\x12\x03\x1a\x1c)\n\x0c\n\x05\x04\x02\x02\x04\x07\
    \x12\x03\x1a'(\n\x0b\n\x04\x04\x02\x02\x05\x12\x03\x1b\x02\"\n\x0c\n\x05\
    \x04\x02\x02\x05\x04\x12\x03\x1b\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x05\
    \x12\x03\x1b\x0b\x11\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03\x1b\x12\x1d\
    \n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03\x1b\x20!\n\x0b\n\x04\x04\x02\
    \x02\x06\x12\x03\x1c\x02&\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03\x1c\
    \x02\n\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03\x1c\x0b\x15\n\x0c\n\x05\
    \x04\x02\x02\x06\x01\x12\x03\x1c\x16!\n\x0c\n\x05\x04\x02\x02\x06\x03\
    \x12\x03\x1c$%\n\x0b\n\x04\x04\x02\x02\x07\x12\x03\x1d\x02&\n\x0c\n\x05\
    \x04\x02\x02\x07\x04\x12\x03\x1d\x02\n\n\x0c\n\x05\x04\x02\x02\x07\x05\
    \x12\x03\x1d\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x07\x01\x12\x03\x1d\x10!\n\
    \x0c\n\x05\x04\x02\x02\x07\x03\x12\x03\x1d$%\n\n\n\x02\x04\x03\x12\x04\
    \x20\0)\x01\n\n\n\x03\x04\x03\x01\x12\x03\x20\x08\x13\n\x0b\n\x04\x04\
    \x03\x02\0\x12\x03!\x02&\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03!\x02\n\n\
    \x0c\n\x05\x04\x03\x02\0\x05\x12\x03!\x0b\x11\n\x0c\n\x05\x04\x03\x02\0\
    \x01\x12\x03!\x12!\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03!$%\n\x0b\n\x04\
    \x04\x03\x02\x01\x12\x03\"\x02\x1b\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\
    \x03\"\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x05\x12\x03\"\x0b\x11\n\x0c\n\
    \x05\x04\x03\x02\x01\x01\x12\x03\"\x12\x16\n\x0c\n\x05\x04\x03\x02\x01\
    \x03\x12\x03\"\x19\x1a\n\x0b\n\x04\x04\x03\x02\x02\x12\x03#\x02\x1a\n\
    \x0c\n\x05\x04\x03\x02\x02\x04\x12\x03#\x02\n\n\x0c\n\x05\x04\x03\x02\
    \x02\x05\x12\x03#\x0b\x11\n\x0c\n\x05\x04\x03\x02\x02\x01\x12\x03#\x12\
    \x15\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03#\x18\x19\n\x0b\n\x04\x04\
    \x03\x02\x03\x12\x03$\x02,\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\x03$\x02\
    \n\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03$\x0b\x10\n\x0c\n\x05\x04\x03\
    \x02\x03\x01\x12\x03$\x11\x19\n\x0c\n\x05\x04\x03\x02\x03\x03\x12\x03$\
    \x1c\x1d\n\x0c\n\x05\x04\x03\x02\x03\x08\x12\x03$\x1e+\n\x0c\n\x05\x04\
    \x03\x02\x03\x07\x12\x03$)*\n\x0b\n\x04\x04\x03\x02\x04\x12\x03%\x02*\n\
    \x0c\n\x05\x04\x03\x02\x04\x04\x12\x03%\x02\n\n\x0c\n\x05\x04\x03\x02\
    \x04\x05\x12\x03%\x0b\x10\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03%\x11\
    \x17\n\x0c\n\x05\x04\x03\x02\x04\x03\x12\x03%\x1a\x1b\n\x0c\n\x05\x04\
    \x03\x02\x04\x08\x12\x03%\x1c)\n\x0c\n\x05\x04\x03\x02\x04\x07\x12\x03%'\
    (\n\x0b\n\x04\x04\x03\x02\x05\x12\x03&\x02\"\n\x0c\n\x05\x04\x03\x02\x05\
    \x04\x12\x03&\x02\n\n\x0c\n\x05\x04\x03\x02\x05\x05\x12\x03&\x0b\x11\n\
    \x0c\n\x05\x04\x03\x02\x05\x01\x12\x03&\x12\x1d\n\x0c\n\x05\x04\x03\x02\
    \x05\x03\x12\x03&\x20!\n\x0b\n\x04\x04\x03\x02\x06\x12\x03'\x02&\n\x0c\n\
    \x05\x04\x03\x02\x06\x04\x12\x03'\x02\n\n\x0c\n\x05\x04\x03\x02\x06\x06\
    \x12\x03'\x0b\x15\n\x0c\n\x05\x04\x03\x02\x06\x01\x12\x03'\x16!\n\x0c\n\
    \x05\x04\x03\x02\x06\x03\x12\x03'$%\n\x0b\n\x04\x04\x03\x02\x07\x12\x03(\
    \x02&\n\x0c\n\x05\x04\x03\x02\x07\x04\x12\x03(\x02\n\n\x0c\n\x05\x04\x03\
    \x02\x07\x05\x12\x03(\x0b\x0f\n\x0c\n\x05\x04\x03\x02\x07\x01\x12\x03(\
    \x10!\n\x0c\n\x05\x04\x03\x02\x07\x03\x12\x03($%\n\n\n\x02\x04\x04\x12\
    \x04+\04\x01\n\n\n\x03\x04\x04\x01\x12\x03+\x08\x11\n\x0b\n\x04\x04\x04\
    \x02\0\x12\x03,\x02&\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03,\x02\n\n\x0c\
    \n\x05\x04\x04\x02\0\x05\x12\x03,\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03,\x12!\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03,$%\n\x0b\n\x04\x04\
    \x04\x02\x01\x12\x03-\x02\x1b\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03-\
    \x02\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03-\x0b\x11\n\x0c\n\x05\x04\
    \x04\x02\x01\x01\x12\x03-\x12\x16\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\
    \x03-\x19\x1a\n\x0b\n\x04\x04\x04\x02\x02\x12\x03.\x02\x1c\n\x0c\n\x05\
    \x04\x04\x02\x02\x04\x12\x03.\x02\n\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\
    \x03.\x0b\x13\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03.\x14\x17\n\x0c\n\
    \x05\x04\x04\x02\x02\x03\x12\x03.\x1a\x1b\n\x0b\n\x04\x04\x04\x02\x03\
    \x12\x03/\x02,\n\x0c\n\x05\x04\x04\x02\x03\x04\x12\x03/\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x03\x05\x12\x03/\x0b\x10\n\x0c\n\x05\x04\x04\x02\x03\
    \x01\x12\x03/\x11\x19\n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03/\x1c\x1d\n\
    \x0c\n\x05\x04\x04\x02\x03\x08\x12\x03/\x1e+\n\x0c\n\x05\x04\x04\x02\x03\
    \x07\x12\x03/)*\n\x0b\n\x04\x04\x04\x02\x04\x12\x030\x02*\n\x0c\n\x05\
    \x04\x04\x02\x04\x04\x12\x030\x02\n\n\x0c\n\x05\x04\x04\x02\x04\x05\x12\
    \x030\x0b\x10\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x030\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x04\x03\x12\x030\x1a\x1b\n\x0c\n\x05\x04\x04\x02\x04\
    \x08\x12\x030\x1c)\n\x0c\n\x05\x04\x04\x02\x04\x07\x12\x030'(\n\x0b\n\
    \x04\x04\x04\x02\x05\x12\x031\x02\"\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\
    \x031\x02\n\n\x0c\n\x05\x04\x04\x02\x05\x05\x12\x031\x0b\x11\n\x0c\n\x05\
    \x04\x04\x02\x05\x01\x12\x031\x12\x1d\n\x0c\n\x05\x04\x04\x02\x05\x03\
    \x12\x031\x20!\n\x0b\n\x04\x04\x04\x02\x06\x12\x032\x02&\n\x0c\n\x05\x04\
    \x04\x02\x06\x04\x12\x032\x02\n\n\x0c\n\x05\x04\x04\x02\x06\x06\x12\x032\
    \x0b\x15\n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x032\x16!\n\x0c\n\x05\x04\
    \x04\x02\x06\x03\x12\x032$%\n\x0b\n\x04\x04\x04\x02\x07\x12\x033\x02&\n\
    \x0c\n\x05\x04\x04\x02\x07\x04\x12\x033\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x07\x05\x12\x033\x0b\x0f\n\x0c\n\x05\x04\x04\x02\x07\x01\x12\x033\x10!\
    \n\x0c\n\x05\x04\x04\x02\x07\x03\x12\x033$%\n\n\n\x02\x04\x05\x12\x046\0\
    ?\x01\n\n\n\x03\x04\x05\x01\x12\x036\x08\x12\n\x0b\n\x04\x04\x05\x02\0\
    \x12\x037\x02&\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x037\x02\n\n\x0c\n\x05\
    \x04\x05\x02\0\x05\x12\x037\x0b\x11\n\x0c\n\x05\x04\x05\x02\0\x01\x12\
    \x037\x12!\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x037$%\n\x0b\n\x04\x04\x05\
    \x02\x01\x12\x038\x02\x1b\n\x0c\n\x05\x04\x05\x02\x01\x04\x12\x038\x02\n\
    \n\x0c\n\x05\x04\x05\x02\x01\x05\x12\x038\x0b\x11\n\x0c\n\x05\x04\x05\
    \x02\x01\x01\x12\x038\x12\x16\n\x0c\n\x05\x04\x05\x02\x01\x03\x12\x038\
    \x19\x1a\n\x0b\n\x04\x04\x05\x02\x02\x12\x039\x02\x1a\n\x0c\n\x05\x04\
    \x05\x02\x02\x04\x12\x039\x02\n\n\x0c\n\x05\x04\x05\x02\x02\x05\x12\x039\
    \x0b\x11\n\x0c\n\x05\x04\x05\x02\x02\x01\x12\x039\x12\x15\n\x0c\n\x05\
    \x04\x05\x02\x02\x03\x12\x039\x18\x19\n\x0b\n\x04\x04\x05\x02\x03\x12\
    \x03:\x02,\n\x0c\n\x05\x04\x05\x02\x03\x04\x12\x03:\x02\n\n\x0c\n\x05\
    \x04\x05\x02\x03\x05\x12\x03:\x0b\x10\n\x0c\n\x05\x04\x05\x02\x03\x01\
    \x12\x03:\x11\x19\n\x0c\n\x05\x04\x05\x02\x03\x03\x12\x03:\x1c\x1d\n\x0c\
    \n\x05\x04\x05\x02\x03\x08\x12\x03:\x1e+\n\x0c\n\x05\x04\x05\x02\x03\x07\
    \x12\x03:)*\n\x0b\n\x04\x04\x05\x02\x04\x12\x03;\x02*\n\x0c\n\x05\x04\
    \x05\x02\x04\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\x05\x02\x04\x05\x12\x03;\
    \x0b\x10\n\x0c\n\x05\x04\x05\x02\x04\x01\x12\x03;\x11\x17\n\x0c\n\x05\
    \x04\x05\x02\x04\x03\x12\x03;\x1a\x1b\n\x0c\n\x05\x04\x05\x02\x04\x08\
    \x12\x03;\x1c)\n\x0c\n\x05\x04\x05\x02\x04\x07\x12\x03;'(\n\x0b\n\x04\
    \x04\x05\x02\x05\x12\x03<\x02\"\n\x0c\n\x05\x04\x05\x02\x05\x04\x12\x03<\
    \x02\n\n\x0c\n\x05\x04\x05\x02\x05\x05\x12\x03<\x0b\x11\n\x0c\n\x05\x04\
    \x05\x02\x05\x01\x12\x03<\x12\x1d\n\x0c\n\x05\x04\x05\x02\x05\x03\x12\
    \x03<\x20!\n\x0b\n\x04\x04\x05\x02\x06\x12\x03=\x02&\n\x0c\n\x05\x04\x05\
    \x02\x06\x04\x12\x03=\x02\n\n\x0c\n\x05\x04\x05\x02\x06\x06\x12\x03=\x0b\
    \x15\n\x0c\n\x05\x04\x05\x02\x06\x01\x12\x03=\x16!\n\x0c\n\x05\x04\x05\
    \x02\x06\x03\x12\x03=$%\n\x0b\n\x04\x04\x05\x02\x07\x12\x03>\x02&\n\x0c\
    \n\x05\x04\x05\x02\x07\x04\x12\x03>\x02\n\n\x0c\n\x05\x04\x05\x02\x07\
    \x05\x12\x03>\x0b\x0f\n\x0c\n\x05\x04\x05\x02\x07\x01\x12\x03>\x10!\n\
    \x0c\n\x05\x04\x05\x02\x07\x03\x12\x03>$%\n\n\n\x02\x04\x06\x12\x04A\0J\
    \x01\n\n\n\x03\x04\x06\x01\x12\x03A\x08\x13\n\x0b\n\x04\x04\x06\x02\0\
    \x12\x03B\x02&\n\x0c\n\x05\x04\x06\x02\0\x04\x12\x03B\x02\n\n\x0c\n\x05\
    \x04\x06\x02\0\x05\x12\x03B\x0b\x11\n\x0c\n\x05\x04\x06\x02\0\x01\x12\
    \x03B\x12!\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03B$%\n\x0b\n\x04\x04\x06\
    \x02\x01\x12\x03C\x02\x1b\n\x0c\n\x05\x04\x06\x02\x01\x04\x12\x03C\x02\n\
    \n\x0c\n\x05\x04\x06\x02\x01\x05\x12\x03C\x0b\x11\n\x0c\n\x05\x04\x06\
    \x02\x01\x01\x12\x03C\x12\x16\n\x0c\n\x05\x04\x06\x02\x01\x03\x12\x03C\
    \x19\x1a\n\x0b\n\x04\x04\x06\x02\x02\x12\x03D\x02\x19\n\x0c\n\x05\x04\
    \x06\x02\x02\x04\x12\x03D\x02\n\n\x0c\n\x05\x04\x06\x02\x02\x05\x12\x03D\
    \x0b\x10\n\x0c\n\x05\x04\x06\x02\x02\x01\x12\x03D\x11\x14\n\x0c\n\x05\
    \x04\x06\x02\x02\x03\x12\x03D\x17\x18\n\x0b\n\x04\x04\x06\x02\x03\x12\
    \x03E\x02,\n\x0c\n\x05\x04\x06\x02\x03\x04\x12\x03E\x02\n\n\x0c\n\x05\
    \x04\x06\x02\x03\x05\x12\x03E\x0b\x10\n\x0c\n\x05\x04\x06\x02\x03\x01\
    \x12\x03E\x11\x19\n\x0c\n\x05\x04\x06\x02\x03\x03\x12\x03E\x1c\x1d\n\x0c\
    \n\x05\x04\x06\x02\x03\x08\x12\x03E\x1e+\n\x0c\n\x05\x04\x06\x02\x03\x07\
    \x12\x03E)*\n\x0b\n\x04\x04\x06\x02\x04\x12\x03F\x02*\n\x0c\n\x05\x04\
    \x06\x02\x04\x04\x12\x03F\x02\n\n\x0c\n\x05\x04\x06\x02\x04\x05\x12\x03F\
    \x0b\x10\n\x0c\n\x05\x04\x06\x02\x04\x01\x12\x03F\x11\x17\n\x0c\n\x05\
    \x04\x06\x02\x04\x03\x12\x03F\x1a\x1b\n\x0c\n\x05\x04\x06\x02\x04\x08\
    \x12\x03F\x1c)\n\x0c\n\x05\x04\x06\x02\x04\x07\x12\x03F'(\n\x0b\n\x04\
    \x04\x06\x02\x05\x12\x03G\x02\"\n\x0c\n\x05\x04\x06\x02\x05\x04\x12\x03G\
    \x02\n\n\x0c\n\x05\x04\x06\x02\x05\x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\
    \x06\x02\x05\x01\x12\x03G\x12\x1d\n\x0c\n\x05\x04\x06\x02\x05\x03\x12\
    \x03G\x20!\n\x0b\n\x04\x04\x06\x02\x06\x12\x03H\x02&\n\x0c\n\x05\x04\x06\
    \x02\x06\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x06\x02\x06\x06\x12\x03H\x0b\
    \x15\n\x0c\n\x05\x04\x06\x02\x06\x01\x12\x03H\x16!\n\x0c\n\x05\x04\x06\
    \x02\x06\x03\x12\x03H$%\n\x0b\n\x04\x04\x06\x02\x07\x12\x03I\x02&\n\x0c\
    \n\x05\x04\x06\x02\x07\x04\x12\x03I\x02\n\n\x0c\n\x05\x04\x06\x02\x07\
    \x05\x12\x03I\x0b\x0f\n\x0c\n\x05\x04\x06\x02\x07\x01\x12\x03I\x10!\n\
    \x0c\n\x05\x04\x06\x02\x07\x03\x12\x03I$%\n\n\n\x02\x04\x07\x12\x04M\0V\
    \x01\n\n\n\x03\x04\x07\x01\x12\x03M\x08\x14\n\x0b\n\x04\x04\x07\x02\0\
    \x12\x03N\x02&\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03N\x02\n\n\x0c\n\x05\
    \x04\x07\x02\0\x05\x12\x03N\x0b\x11\n\x0c\n\x05\x04\x07\x02\0\x01\x12\
    \x03N\x12!\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03N$%\n\x0b\n\x04\x04\x07\
    \x02\x01\x12\x03O\x02\x1b\n\x0c\n\x05\x04\x07\x02\x01\x04\x12\x03O\x02\n\
    \n\x0c\n\x05\x04\x07\x02\x01\x05\x12\x03O\x0b\x11\n\x0c\n\x05\x04\x07\
    \x02\x01\x01\x12\x03O\x12\x16\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03O\
    \x19\x1a\n\x0b\n\x04\x04\x07\x02\x02\x12\x03P\x02\x1a\n\x0c\n\x05\x04\
    \x07\x02\x02\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03P\
    \x0b\x11\n\x0c\n\x05\x04\x07\x02\x02\x01\x12\x03P\x12\x15\n\x0c\n\x05\
    \x04\x07\x02\x02\x03\x12\x03P\x18\x19\n\x0b\n\x04\x04\x07\x02\x03\x12\
    \x03Q\x02,\n\x0c\n\x05\x04\x07\x02\x03\x04\x12\x03Q\x02\n\n\x0c\n\x05\
    \x04\x07\x02\x03\x05\x12\x03Q\x0b\x10\n\x0c\n\x05\x04\x07\x02\x03\x01\
    \x12\x03Q\x11\x19\n\x0c\n\x05\x04\x07\x02\x03\x03\x12\x03Q\x1c\x1d\n\x0c\
    \n\x05\x04\x07\x02\x03\x08\x12\x03Q\x1e+\n\x0c\n\x05\x04\x07\x02\x03\x07\
    \x12\x03Q)*\n\x0b\n\x04\x04\x07\x02\x04\x12\x03R\x02*\n\x0c\n\x05\x04\
    \x07\x02\x04\x04\x12\x03R\x02\n\n\x0c\n\x05\x04\x07\x02\x04\x05\x12\x03R\
    \x0b\x10\n\x0c\n\x05\x04\x07\x02\x04\x01\x12\x03R\x11\x17\n\x0c\n\x05\
    \x04\x07\x02\x04\x03\x12\x03R\x1a\x1b\n\x0c\n\x05\x04\x07\x02\x04\x08\
    \x12\x03R\x1c)\n\x0c\n\x05\x04\x07\x02\x04\x07\x12\x03R'(\n\x0b\n\x04\
    \x04\x07\x02\x05\x12\x03S\x02\"\n\x0c\n\x05\x04\x07\x02\x05\x04\x12\x03S\
    \x02\n\n\x0c\n\x05\x04\x07\x02\x05\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\
    \x07\x02\x05\x01\x12\x03S\x12\x1d\n\x0c\n\x05\x04\x07\x02\x05\x03\x12\
    \x03S\x20!\n\x0b\n\x04\x04\x07\x02\x06\x12\x03T\x02&\n\x0c\n\x05\x04\x07\
    \x02\x06\x04\x12\x03T\x02\n\n\x0c\n\x05\x04\x07\x02\x06\x06\x12\x03T\x0b\
    \x15\n\x0c\n\x05\x04\x07\x02\x06\x01\x12\x03T\x16!\n\x0c\n\x05\x04\x07\
    \x02\x06\x03\x12\x03T$%\n\x0b\n\x04\x04\x07\x02\x07\x12\x03U\x02&\n\x0c\
    \n\x05\x04\x07\x02\x07\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x07\x02\x07\
    \x05\x12\x03U\x0b\x0f\n\x0c\n\x05\x04\x07\x02\x07\x01\x12\x03U\x10!\n\
    \x0c\n\x05\x04\x07\x02\x07\x03\x12\x03U$%\n\n\n\x02\x04\x08\x12\x04X\0b\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03X\x08\x14\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03Y\x02&\n\x0c\n\x05\x04\x08\x02\0\x04\x12\x03Y\x02\n\n\x0c\n\x05\
    \x04\x08\x02\0\x05\x12\x03Y\x0b\x11\n\x0c\n\x05\x04\x08\x02\0\x01\x12\
    \x03Y\x12!\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03Y$%\n\x0b\n\x04\x04\x08\
    \x02\x01\x12\x03Z\x02\x1b\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03Z\x02\n\
    \n\x0c\n\x05\x04\x08\x02\x01\x05\x12\x03Z\x0b\x11\n\x0c\n\x05\x04\x08\
    \x02\x01\x01\x12\x03Z\x12\x16\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03Z\
    \x19\x1a\nN\n\x04\x04\x08\x02\x02\x12\x03\\\x02\x1a\x1aA\x20No\x20packed\
    \x20here\x20as\x20this\x20is\x20available\x20only\x20for\x20primitive\
    \x20fields.\r\n\n\x0c\n\x05\x04\x08\x02\x02\x04\x12\x03\\\x02\n\n\x0c\n\
    \x05\x04\x08\x02\x02\x05\x12\x03\\\x0b\x11\n\x0c\n\x05\x04\x08\x02\x02\
    \x01\x12\x03\\\x12\x15\n\x0c\n\x05\x04\x08\x02\x02\x03\x12\x03\\\x18\x19\
    \n\x0b\n\x04\x04\x08\x02\x03\x12\x03]\x02,\n\x0c\n\x05\x04\x08\x02\x03\
    \x04\x12\x03]\x02\n\n\x0c\n\x05\x04\x08\x02\x03\x05\x12\x03]\x0b\x10\n\
    \x0c\n\x05\x04\x08\x02\x03\x01\x12\x03]\x11\x19\n\x0c\n\x05\x04\x08\x02\
    \x03\x03\x12\x03]\x1c\x1d\n\x0c\n\x05\x04\x08\x02\x03\x08\x12\x03]\x1e+\
    \n\x0c\n\x05\x04\x08\x02\x03\x07\x12\x03])*\n\x0b\n\x04\x04\x08\x02\x04\
    \x12\x03^\x02*\n\x0c\n\x05\x04\x08\x02\x04\x04\x12\x03^\x02\n\n\x0c\n\
    \x05\x04\x08\x02\x04\x05\x12\x03^\x0b\x10\n\x0c\n\x05\x04\x08\x02\x04\
    \x01\x12\x03^\x11\x17\n\x0c\n\x05\x04\x08\x02\x04\x03\x12\x03^\x1a\x1b\n\
    \x0c\n\x05\x04\x08\x02\x04\x08\x12\x03^\x1c)\n\x0c\n\x05\x04\x08\x02\x04\
    \x07\x12\x03^'(\n\x0b\n\x04\x04\x08\x02\x05\x12\x03_\x02\"\n\x0c\n\x05\
    \x04\x08\x02\x05\x04\x12\x03_\x02\n\n\x0c\n\x05\x04\x08\x02\x05\x05\x12\
    \x03_\x0b\x11\n\x0c\n\x05\x04\x08\x02\x05\x01\x12\x03_\x12\x1d\n\x0c\n\
    \x05\x04\x08\x02\x05\x03\x12\x03_\x20!\n\x0b\n\x04\x04\x08\x02\x06\x12\
    \x03`\x02&\n\x0c\n\x05\x04\x08\x02\x06\x04\x12\x03`\x02\n\n\x0c\n\x05\
    \x04\x08\x02\x06\x06\x12\x03`\x0b\x15\n\x0c\n\x05\x04\x08\x02\x06\x01\
    \x12\x03`\x16!\n\x0c\n\x05\x04\x08\x02\x06\x03\x12\x03`$%\n\x0b\n\x04\
    \x04\x08\x02\x07\x12\x03a\x02&\n\x0c\n\x05\x04\x08\x02\x07\x04\x12\x03a\
    \x02\n\n\x0c\n\x05\x04\x08\x02\x07\x05\x12\x03a\x0b\x0f\n\x0c\n\x05\x04\
    \x08\x02\x07\x01\x12\x03a\x10!\n\x0c\n\x05\x04\x08\x02\x07\x03\x12\x03a$\
    %\nQ\n\x02\x04\t\x12\x04e\0n\x01\x1aE\x20VectorChar\x20is\x20the\x20same\
    \x20as\x20ScalarChar\x20as\x20we\x20use\x20ByteString\x20for\x20both\r\n\
    \n\n\n\x03\x04\t\x01\x12\x03e\x08\x12\n\x0b\n\x04\x04\t\x02\0\x12\x03f\
    \x02&\n\x0c\n\x05\x04\t\x02\0\x04\x12\x03f\x02\n\n\x0c\n\x05\x04\t\x02\0\
    \x05\x12\x03f\x0b\x11\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03f\x12!\n\x0c\n\
    \x05\x04\t\x02\0\x03\x12\x03f$%\n\x0b\n\x04\x04\t\x02\x01\x12\x03g\x02\
    \x1b\n\x0c\n\x05\x04\t\x02\x01\x04\x12\x03g\x02\n\n\x0c\n\x05\x04\t\x02\
    \x01\x05\x12\x03g\x0b\x11\n\x0c\n\x05\x04\t\x02\x01\x01\x12\x03g\x12\x16\
    \n\x0c\n\x05\x04\t\x02\x01\x03\x12\x03g\x19\x1a\n\x0b\n\x04\x04\t\x02\
    \x02\x12\x03h\x02\x19\n\x0c\n\x05\x04\t\x02\x02\x04\x12\x03h\x02\n\n\x0c\
    \n\x05\x04\t\x02\x02\x05\x12\x03h\x0b\x10\n\x0c\n\x05\x04\t\x02\x02\x01\
    \x12\x03h\x11\x14\n\x0c\n\x05\x04\t\x02\x02\x03\x12\x03h\x17\x18\n\x0b\n\
    \x04\x04\t\x02\x03\x12\x03i\x02,\n\x0c\n\x05\x04\t\x02\x03\x04\x12\x03i\
    \x02\n\n\x0c\n\x05\x04\t\x02\x03\x05\x12\x03i\x0b\x10\n\x0c\n\x05\x04\t\
    \x02\x03\x01\x12\x03i\x11\x19\n\x0c\n\x05\x04\t\x02\x03\x03\x12\x03i\x1c\
    \x1d\n\x0c\n\x05\x04\t\x02\x03\x08\x12\x03i\x1e+\n\x0c\n\x05\x04\t\x02\
    \x03\x07\x12\x03i)*\n\x0b\n\x04\x04\t\x02\x04\x12\x03j\x02*\n\x0c\n\x05\
    \x04\t\x02\x04\x04\x12\x03j\x02\n\n\x0c\n\x05\x04\t\x02\x04\x05\x12\x03j\
    \x0b\x10\n\x0c\n\x05\x04\t\x02\x04\x01\x12\x03j\x11\x17\n\x0c\n\x05\x04\
    \t\x02\x04\x03\x12\x03j\x1a\x1b\n\x0c\n\x05\x04\t\x02\x04\x08\x12\x03j\
    \x1c)\n\x0c\n\x05\x04\t\x02\x04\x07\x12\x03j'(\n\x0b\n\x04\x04\t\x02\x05\
    \x12\x03k\x02\"\n\x0c\n\x05\x04\t\x02\x05\x04\x12\x03k\x02\n\n\x0c\n\x05\
    \x04\t\x02\x05\x05\x12\x03k\x0b\x11\n\x0c\n\x05\x04\t\x02\x05\x01\x12\
    \x03k\x12\x1d\n\x0c\n\x05\x04\t\x02\x05\x03\x12\x03k\x20!\n\x0b\n\x04\
    \x04\t\x02\x06\x12\x03l\x02&\n\x0c\n\x05\x04\t\x02\x06\x04\x12\x03l\x02\
    \n\n\x0c\n\x05\x04\t\x02\x06\x06\x12\x03l\x0b\x15\n\x0c\n\x05\x04\t\x02\
    \x06\x01\x12\x03l\x16!\n\x0c\n\x05\x04\t\x02\x06\x03\x12\x03l$%\n\x0b\n\
    \x04\x04\t\x02\x07\x12\x03m\x02&\n\x0c\n\x05\x04\t\x02\x07\x04\x12\x03m\
    \x02\n\n\x0c\n\x05\x04\t\x02\x07\x05\x12\x03m\x0b\x0f\n\x0c\n\x05\x04\t\
    \x02\x07\x01\x12\x03m\x10!\n\x0c\n\x05\x04\t\x02\x07\x03\x12\x03m$%\n\n\
    \n\x02\x04\n\x12\x04p\0y\x01\n\n\n\x03\x04\n\x01\x12\x03p\x08\x13\n\x0b\
    \n\x04\x04\n\x02\0\x12\x03q\x02&\n\x0c\n\x05\x04\n\x02\0\x04\x12\x03q\
    \x02\n\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03q\x0b\x11\n\x0c\n\x05\x04\n\
    \x02\0\x01\x12\x03q\x12!\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03q$%\n\x0b\n\
    \x04\x04\n\x02\x01\x12\x03r\x02\x1b\n\x0c\n\x05\x04\n\x02\x01\x04\x12\
    \x03r\x02\n\n\x0c\n\x05\x04\n\x02\x01\x05\x12\x03r\x0b\x11\n\x0c\n\x05\
    \x04\n\x02\x01\x01\x12\x03r\x12\x16\n\x0c\n\x05\x04\n\x02\x01\x03\x12\
    \x03r\x19\x1a\n\x0b\n\x04\x04\n\x02\x02\x12\x03s\x02*\n\x0c\n\x05\x04\n\
    \x02\x02\x04\x12\x03s\x02\n\n\x0c\n\x05\x04\n\x02\x02\x05\x12\x03s\x0b\
    \x11\n\x0c\n\x05\x04\n\x02\x02\x01\x12\x03s\x12\x15\n\x0c\n\x05\x04\n\
    \x02\x02\x03\x12\x03s\x18\x19\n\x0c\n\x05\x04\n\x02\x02\x08\x12\x03s\x1a\
    )\n\x0f\n\x08\x04\n\x02\x02\x08\xe7\x07\0\x12\x03s\x1b(\n\x10\n\t\x04\n\
    \x02\x02\x08\xe7\x07\0\x02\x12\x03s\x1b!\n\x11\n\n\x04\n\x02\x02\x08\xe7\
    \x07\0\x02\0\x12\x03s\x1b!\n\x12\n\x0b\x04\n\x02\x02\x08\xe7\x07\0\x02\0\
    \x01\x12\x03s\x1b!\n\x10\n\t\x04\n\x02\x02\x08\xe7\x07\0\x03\x12\x03s$(\
    \n\x0b\n\x04\x04\n\x02\x03\x12\x03t\x02,\n\x0c\n\x05\x04\n\x02\x03\x04\
    \x12\x03t\x02\n\n\x0c\n\x05\x04\n\x02\x03\x05\x12\x03t\x0b\x10\n\x0c\n\
    \x05\x04\n\x02\x03\x01\x12\x03t\x11\x19\n\x0c\n\x05\x04\n\x02\x03\x03\
    \x12\x03t\x1c\x1d\n\x0c\n\x05\x04\n\x02\x03\x08\x12\x03t\x1e+\n\x0c\n\
    \x05\x04\n\x02\x03\x07\x12\x03t)*\n\x0b\n\x04\x04\n\x02\x04\x12\x03u\x02\
    *\n\x0c\n\x05\x04\n\x02\x04\x04\x12\x03u\x02\n\n\x0c\n\x05\x04\n\x02\x04\
    \x05\x12\x03u\x0b\x10\n\x0c\n\x05\x04\n\x02\x04\x01\x12\x03u\x11\x17\n\
    \x0c\n\x05\x04\n\x02\x04\x03\x12\x03u\x1a\x1b\n\x0c\n\x05\x04\n\x02\x04\
    \x08\x12\x03u\x1c)\n\x0c\n\x05\x04\n\x02\x04\x07\x12\x03u'(\n\x0b\n\x04\
    \x04\n\x02\x05\x12\x03v\x02\"\n\x0c\n\x05\x04\n\x02\x05\x04\x12\x03v\x02\
    \n\n\x0c\n\x05\x04\n\x02\x05\x05\x12\x03v\x0b\x11\n\x0c\n\x05\x04\n\x02\
    \x05\x01\x12\x03v\x12\x1d\n\x0c\n\x05\x04\n\x02\x05\x03\x12\x03v\x20!\n\
    \x0b\n\x04\x04\n\x02\x06\x12\x03w\x02&\n\x0c\n\x05\x04\n\x02\x06\x04\x12\
    \x03w\x02\n\n\x0c\n\x05\x04\n\x02\x06\x06\x12\x03w\x0b\x15\n\x0c\n\x05\
    \x04\n\x02\x06\x01\x12\x03w\x16!\n\x0c\n\x05\x04\n\x02\x06\x03\x12\x03w$\
    %\n\x0b\n\x04\x04\n\x02\x07\x12\x03x\x02&\n\x0c\n\x05\x04\n\x02\x07\x04\
    \x12\x03x\x02\n\n\x0c\n\x05\x04\n\x02\x07\x05\x12\x03x\x0b\x0f\n\x0c\n\
    \x05\x04\n\x02\x07\x01\x12\x03x\x10!\n\x0c\n\x05\x04\n\x02\x07\x03\x12\
    \x03x$%\n\x0b\n\x02\x04\x0b\x12\x05{\0\x84\x01\x01\n\n\n\x03\x04\x0b\x01\
    \x12\x03{\x08\x11\n\x0b\n\x04\x04\x0b\x02\0\x12\x03|\x02&\n\x0c\n\x05\
    \x04\x0b\x02\0\x04\x12\x03|\x02\n\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03|\
    \x0b\x11\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03|\x12!\n\x0c\n\x05\x04\x0b\
    \x02\0\x03\x12\x03|$%\n\x0b\n\x04\x04\x0b\x02\x01\x12\x03}\x02\x1b\n\x0c\
    \n\x05\x04\x0b\x02\x01\x04\x12\x03}\x02\n\n\x0c\n\x05\x04\x0b\x02\x01\
    \x05\x12\x03}\x0b\x11\n\x0c\n\x05\x04\x0b\x02\x01\x01\x12\x03}\x12\x16\n\
    \x0c\n\x05\x04\x0b\x02\x01\x03\x12\x03}\x19\x1a\n\x0b\n\x04\x04\x0b\x02\
    \x02\x12\x03~\x02-\n\x0c\n\x05\x04\x0b\x02\x02\x04\x12\x03~\x02\n\n\x0c\
    \n\x05\x04\x0b\x02\x02\x05\x12\x03~\x0b\x13\n\x0c\n\x05\x04\x0b\x02\x02\
    \x01\x12\x03~\x14\x17\n\x0c\n\x05\x04\x0b\x02\x02\x03\x12\x03~\x1a\x1b\n\
    \x0c\n\x05\x04\x0b\x02\x02\x08\x12\x03~\x1d,\n\x0f\n\x08\x04\x0b\x02\x02\
    \x08\xe7\x07\0\x12\x03~\x1e+\n\x10\n\t\x04\x0b\x02\x02\x08\xe7\x07\0\x02\
    \x12\x03~\x1e$\n\x11\n\n\x04\x0b\x02\x02\x08\xe7\x07\0\x02\0\x12\x03~\
    \x1e$\n\x12\n\x0b\x04\x0b\x02\x02\x08\xe7\x07\0\x02\0\x01\x12\x03~\x1e$\
    \n\x10\n\t\x04\x0b\x02\x02\x08\xe7\x07\0\x03\x12\x03~'+\n\x0b\n\x04\x04\
    \x0b\x02\x03\x12\x03\x7f\x02,\n\x0c\n\x05\x04\x0b\x02\x03\x04\x12\x03\
    \x7f\x02\n\n\x0c\n\x05\x04\x0b\x02\x03\x05\x12\x03\x7f\x0b\x10\n\x0c\n\
    \x05\x04\x0b\x02\x03\x01\x12\x03\x7f\x11\x19\n\x0c\n\x05\x04\x0b\x02\x03\
    \x03\x12\x03\x7f\x1c\x1d\n\x0c\n\x05\x04\x0b\x02\x03\x08\x12\x03\x7f\x1e\
    +\n\x0c\n\x05\x04\x0b\x02\x03\x07\x12\x03\x7f)*\n\x0c\n\x04\x04\x0b\x02\
    \x04\x12\x04\x80\x01\x02*\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x80\x01\
    \x02\n\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\x80\x01\x0b\x10\n\r\n\x05\
    \x04\x0b\x02\x04\x01\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x04\
    \x03\x12\x04\x80\x01\x1a\x1b\n\r\n\x05\x04\x0b\x02\x04\x08\x12\x04\x80\
    \x01\x1c)\n\r\n\x05\x04\x0b\x02\x04\x07\x12\x04\x80\x01'(\n\x0c\n\x04\
    \x04\x0b\x02\x05\x12\x04\x81\x01\x02\"\n\r\n\x05\x04\x0b\x02\x05\x04\x12\
    \x04\x81\x01\x02\n\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\x81\x01\x0b\x11\
    \n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\x81\x01\x12\x1d\n\r\n\x05\x04\x0b\
    \x02\x05\x03\x12\x04\x81\x01\x20!\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\
    \x82\x01\x02&\n\r\n\x05\x04\x0b\x02\x06\x04\x12\x04\x82\x01\x02\n\n\r\n\
    \x05\x04\x0b\x02\x06\x06\x12\x04\x82\x01\x0b\x15\n\r\n\x05\x04\x0b\x02\
    \x06\x01\x12\x04\x82\x01\x16!\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\x82\
    \x01$%\n\x0c\n\x04\x04\x0b\x02\x07\x12\x04\x83\x01\x02&\n\r\n\x05\x04\
    \x0b\x02\x07\x04\x12\x04\x83\x01\x02\n\n\r\n\x05\x04\x0b\x02\x07\x05\x12\
    \x04\x83\x01\x0b\x0f\n\r\n\x05\x04\x0b\x02\x07\x01\x12\x04\x83\x01\x10!\
    \n\r\n\x05\x04\x0b\x02\x07\x03\x12\x04\x83\x01$%\n\x0c\n\x02\x04\x0c\x12\
    \x06\x86\x01\0\x8f\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x86\x01\x08\
    \x12\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\x87\x01\x02&\n\r\n\x05\x04\x0c\
    \x02\0\x04\x12\x04\x87\x01\x02\n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\x87\
    \x01\x0b\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x87\x01\x12!\n\r\n\x05\
    \x04\x0c\x02\0\x03\x12\x04\x87\x01$%\n\x0c\n\x04\x04\x0c\x02\x01\x12\x04\
    \x88\x01\x02\x1b\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\x88\x01\x02\n\n\r\
    \n\x05\x04\x0c\x02\x01\x05\x12\x04\x88\x01\x0b\x11\n\r\n\x05\x04\x0c\x02\
    \x01\x01\x12\x04\x88\x01\x12\x16\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\
    \x88\x01\x19\x1a\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\x89\x01\x02*\n\r\n\
    \x05\x04\x0c\x02\x02\x04\x12\x04\x89\x01\x02\n\n\r\n\x05\x04\x0c\x02\x02\
    \x05\x12\x04\x89\x01\x0b\x11\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\x89\
    \x01\x12\x15\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\x89\x01\x18\x19\n\r\n\
    \x05\x04\x0c\x02\x02\x08\x12\x04\x89\x01\x1a)\n\x10\n\x08\x04\x0c\x02\
    \x02\x08\xe7\x07\0\x12\x04\x89\x01\x1b(\n\x11\n\t\x04\x0c\x02\x02\x08\
    \xe7\x07\0\x02\x12\x04\x89\x01\x1b!\n\x12\n\n\x04\x0c\x02\x02\x08\xe7\
    \x07\0\x02\0\x12\x04\x89\x01\x1b!\n\x13\n\x0b\x04\x0c\x02\x02\x08\xe7\
    \x07\0\x02\0\x01\x12\x04\x89\x01\x1b!\n\x11\n\t\x04\x0c\x02\x02\x08\xe7\
    \x07\0\x03\x12\x04\x89\x01$(\n\x0c\n\x04\x04\x0c\x02\x03\x12\x04\x8a\x01\
    \x02,\n\r\n\x05\x04\x0c\x02\x03\x04\x12\x04\x8a\x01\x02\n\n\r\n\x05\x04\
    \x0c\x02\x03\x05\x12\x04\x8a\x01\x0b\x10\n\r\n\x05\x04\x0c\x02\x03\x01\
    \x12\x04\x8a\x01\x11\x19\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\x8a\x01\
    \x1c\x1d\n\r\n\x05\x04\x0c\x02\x03\x08\x12\x04\x8a\x01\x1e+\n\r\n\x05\
    \x04\x0c\x02\x03\x07\x12\x04\x8a\x01)*\n\x0c\n\x04\x04\x0c\x02\x04\x12\
    \x04\x8b\x01\x02*\n\r\n\x05\x04\x0c\x02\x04\x04\x12\x04\x8b\x01\x02\n\n\
    \r\n\x05\x04\x0c\x02\x04\x05\x12\x04\x8b\x01\x0b\x10\n\r\n\x05\x04\x0c\
    \x02\x04\x01\x12\x04\x8b\x01\x11\x17\n\r\n\x05\x04\x0c\x02\x04\x03\x12\
    \x04\x8b\x01\x1a\x1b\n\r\n\x05\x04\x0c\x02\x04\x08\x12\x04\x8b\x01\x1c)\
    \n\r\n\x05\x04\x0c\x02\x04\x07\x12\x04\x8b\x01'(\n\x0c\n\x04\x04\x0c\x02\
    \x05\x12\x04\x8c\x01\x02\"\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\x8c\x01\
    \x02\n\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\x8c\x01\x0b\x11\n\r\n\x05\
    \x04\x0c\x02\x05\x01\x12\x04\x8c\x01\x12\x1d\n\r\n\x05\x04\x0c\x02\x05\
    \x03\x12\x04\x8c\x01\x20!\n\x0c\n\x04\x04\x0c\x02\x06\x12\x04\x8d\x01\
    \x02&\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\x8d\x01\x02\n\n\r\n\x05\x04\
    \x0c\x02\x06\x06\x12\x04\x8d\x01\x0b\x15\n\r\n\x05\x04\x0c\x02\x06\x01\
    \x12\x04\x8d\x01\x16!\n\r\n\x05\x04\x0c\x02\x06\x03\x12\x04\x8d\x01$%\n\
    \x0c\n\x04\x04\x0c\x02\x07\x12\x04\x8e\x01\x02&\n\r\n\x05\x04\x0c\x02\
    \x07\x04\x12\x04\x8e\x01\x02\n\n\r\n\x05\x04\x0c\x02\x07\x05\x12\x04\x8e\
    \x01\x0b\x0f\n\r\n\x05\x04\x0c\x02\x07\x01\x12\x04\x8e\x01\x10!\n\r\n\
    \x05\x04\x0c\x02\x07\x03\x12\x04\x8e\x01$%\n\x0c\n\x02\x04\r\x12\x06\x91\
    \x01\0\x9a\x01\x01\n\x0b\n\x03\x04\r\x01\x12\x04\x91\x01\x08\x13\n\x0c\n\
    \x04\x04\r\x02\0\x12\x04\x92\x01\x02&\n\r\n\x05\x04\r\x02\0\x04\x12\x04\
    \x92\x01\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\x92\x01\x0b\x11\n\r\n\
    \x05\x04\r\x02\0\x01\x12\x04\x92\x01\x12!\n\r\n\x05\x04\r\x02\0\x03\x12\
    \x04\x92\x01$%\n\x0c\n\x04\x04\r\x02\x01\x12\x04\x93\x01\x02\x1b\n\r\n\
    \x05\x04\r\x02\x01\x04\x12\x04\x93\x01\x02\n\n\r\n\x05\x04\r\x02\x01\x05\
    \x12\x04\x93\x01\x0b\x11\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\x93\x01\x12\
    \x16\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\x93\x01\x19\x1a\n\x0c\n\x04\x04\
    \r\x02\x02\x12\x04\x94\x01\x02*\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\x94\
    \x01\x02\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\x94\x01\x0b\x10\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\x94\x01\x11\x14\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\x94\x01\x17\x18\n\r\n\x05\x04\r\x02\x02\x08\x12\x04\x94\x01\x1a\
    )\n\x10\n\x08\x04\r\x02\x02\x08\xe7\x07\0\x12\x04\x94\x01\x1b(\n\x11\n\t\
    \x04\r\x02\x02\x08\xe7\x07\0\x02\x12\x04\x94\x01\x1b!\n\x12\n\n\x04\r\
    \x02\x02\x08\xe7\x07\0\x02\0\x12\x04\x94\x01\x1b!\n\x13\n\x0b\x04\r\x02\
    \x02\x08\xe7\x07\0\x02\0\x01\x12\x04\x94\x01\x1b!\n\x11\n\t\x04\r\x02\
    \x02\x08\xe7\x07\0\x03\x12\x04\x94\x01$(\n\x0c\n\x04\x04\r\x02\x03\x12\
    \x04\x95\x01\x02,\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\x95\x01\x02\n\n\r\
    \n\x05\x04\r\x02\x03\x05\x12\x04\x95\x01\x0b\x10\n\r\n\x05\x04\r\x02\x03\
    \x01\x12\x04\x95\x01\x11\x19\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\x95\x01\
    \x1c\x1d\n\r\n\x05\x04\r\x02\x03\x08\x12\x04\x95\x01\x1e+\n\r\n\x05\x04\
    \r\x02\x03\x07\x12\x04\x95\x01)*\n\x0c\n\x04\x04\r\x02\x04\x12\x04\x96\
    \x01\x02*\n\r\n\x05\x04\r\x02\x04\x04\x12\x04\x96\x01\x02\n\n\r\n\x05\
    \x04\r\x02\x04\x05\x12\x04\x96\x01\x0b\x10\n\r\n\x05\x04\r\x02\x04\x01\
    \x12\x04\x96\x01\x11\x17\n\r\n\x05\x04\r\x02\x04\x03\x12\x04\x96\x01\x1a\
    \x1b\n\r\n\x05\x04\r\x02\x04\x08\x12\x04\x96\x01\x1c)\n\r\n\x05\x04\r\
    \x02\x04\x07\x12\x04\x96\x01'(\n\x0c\n\x04\x04\r\x02\x05\x12\x04\x97\x01\
    \x02\"\n\r\n\x05\x04\r\x02\x05\x04\x12\x04\x97\x01\x02\n\n\r\n\x05\x04\r\
    \x02\x05\x05\x12\x04\x97\x01\x0b\x11\n\r\n\x05\x04\r\x02\x05\x01\x12\x04\
    \x97\x01\x12\x1d\n\r\n\x05\x04\r\x02\x05\x03\x12\x04\x97\x01\x20!\n\x0c\
    \n\x04\x04\r\x02\x06\x12\x04\x98\x01\x02&\n\r\n\x05\x04\r\x02\x06\x04\
    \x12\x04\x98\x01\x02\n\n\r\n\x05\x04\r\x02\x06\x06\x12\x04\x98\x01\x0b\
    \x15\n\r\n\x05\x04\r\x02\x06\x01\x12\x04\x98\x01\x16!\n\r\n\x05\x04\r\
    \x02\x06\x03\x12\x04\x98\x01$%\n\x0c\n\x04\x04\r\x02\x07\x12\x04\x99\x01\
    \x02&\n\r\n\x05\x04\r\x02\x07\x04\x12\x04\x99\x01\x02\n\n\r\n\x05\x04\r\
    \x02\x07\x05\x12\x04\x99\x01\x0b\x0f\n\r\n\x05\x04\r\x02\x07\x01\x12\x04\
    \x99\x01\x10!\n\r\n\x05\x04\r\x02\x07\x03\x12\x04\x99\x01$%\n\x0c\n\x02\
    \x04\x0e\x12\x06\x9d\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\
    \x9d\x01\x08\x14\n\x0c\n\x04\x04\x0e\x02\0\x12\x04\x9e\x01\x02&\n\r\n\
    \x05\x04\x0e\x02\0\x04\x12\x04\x9e\x01\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\x9e\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x9e\x01\x12\
    !\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\x9e\x01$%\n\x0c\n\x04\x04\x0e\x02\
    \x01\x12\x04\x9f\x01\x02\x1b\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x9f\
    \x01\x02\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\x9f\x01\x0b\x11\n\r\n\
    \x05\x04\x0e\x02\x01\x01\x12\x04\x9f\x01\x12\x16\n\r\n\x05\x04\x0e\x02\
    \x01\x03\x12\x04\x9f\x01\x19\x1a\n\x0c\n\x04\x04\x0e\x02\x02\x12\x04\xa0\
    \x01\x02+\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\
    \x04\x0e\x02\x02\x05\x12\x04\xa0\x01\x0b\x11\n\r\n\x05\x04\x0e\x02\x02\
    \x01\x12\x04\xa0\x01\x12\x15\n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\xa0\
    \x01\x18\x19\n\r\n\x05\x04\x0e\x02\x02\x08\x12\x04\xa0\x01\x1b*\n\x10\n\
    \x08\x04\x0e\x02\x02\x08\xe7\x07\0\x12\x04\xa0\x01\x1c)\n\x11\n\t\x04\
    \x0e\x02\x02\x08\xe7\x07\0\x02\x12\x04\xa0\x01\x1c\"\n\x12\n\n\x04\x0e\
    \x02\x02\x08\xe7\x07\0\x02\0\x12\x04\xa0\x01\x1c\"\n\x13\n\x0b\x04\x0e\
    \x02\x02\x08\xe7\x07\0\x02\0\x01\x12\x04\xa0\x01\x1c\"\n\x11\n\t\x04\x0e\
    \x02\x02\x08\xe7\x07\0\x03\x12\x04\xa0\x01%)\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\xa1\x01\x02,\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xa1\x01\x02\
    \n\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xa1\x01\x0b\x10\n\r\n\x05\x04\
    \x0e\x02\x03\x01\x12\x04\xa1\x01\x11\x19\n\r\n\x05\x04\x0e\x02\x03\x03\
    \x12\x04\xa1\x01\x1c\x1d\n\r\n\x05\x04\x0e\x02\x03\x08\x12\x04\xa1\x01\
    \x1e+\n\r\n\x05\x04\x0e\x02\x03\x07\x12\x04\xa1\x01)*\n\x0c\n\x04\x04\
    \x0e\x02\x04\x12\x04\xa2\x01\x02*\n\r\n\x05\x04\x0e\x02\x04\x04\x12\x04\
    \xa2\x01\x02\n\n\r\n\x05\x04\x0e\x02\x04\x05\x12\x04\xa2\x01\x0b\x10\n\r\
    \n\x05\x04\x0e\x02\x04\x01\x12\x04\xa2\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x04\x03\x12\x04\xa2\x01\x1a\x1b\n\r\n\x05\x04\x0e\x02\x04\x08\x12\x04\
    \xa2\x01\x1c)\n\r\n\x05\x04\x0e\x02\x04\x07\x12\x04\xa2\x01'(\n\x0c\n\
    \x04\x04\x0e\x02\x05\x12\x04\xa3\x01\x02\"\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\xa3\x01\x02\n\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xa3\x01\x0b\
    \x11\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xa3\x01\x12\x1d\n\r\n\x05\x04\
    \x0e\x02\x05\x03\x12\x04\xa3\x01\x20!\n\x0c\n\x04\x04\x0e\x02\x06\x12\
    \x04\xa4\x01\x02&\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xa4\x01\x02\n\n\
    \r\n\x05\x04\x0e\x02\x06\x06\x12\x04\xa4\x01\x0b\x15\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\xa4\x01\x16!\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \xa4\x01$%\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xa5\x01\x02&\n\r\n\x05\
    \x04\x0e\x02\x07\x04\x12\x04\xa5\x01\x02\n\n\r\n\x05\x04\x0e\x02\x07\x05\
    \x12\x04\xa5\x01\x0b\x0f\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xa5\x01\
    \x10!\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xa5\x01$%\nh\n\x02\x04\x0f\
    \x12\x06\xa9\x01\0\xb4\x01\x01\x1aZ\x20A\x20generic\x20v4\x20container;\
    \x20we\x20simply\x20store\x20the\x20bytes\x20as\x20obtained\x20from\x20E\
    PICS\x20v4\x20as\x20the\x20val.\r\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\xa9\
    \x01\x08\x16\n\x0c\n\x04\x04\x0f\x02\0\x12\x04\xaa\x01\x02&\n\r\n\x05\
    \x04\x0f\x02\0\x04\x12\x04\xaa\x01\x02\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\
    \x04\xaa\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xaa\x01\x12!\n\
    \r\n\x05\x04\x0f\x02\0\x03\x12\x04\xaa\x01$%\n\x0c\n\x04\x04\x0f\x02\x01\
    \x12\x04\xab\x01\x02\x1b\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xab\x01\
    \x02\n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xab\x01\x0b\x11\n\r\n\x05\
    \x04\x0f\x02\x01\x01\x12\x04\xab\x01\x12\x16\n\r\n\x05\x04\x0f\x02\x01\
    \x03\x12\x04\xab\x01\x19\x1a\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xac\x01\
    \x02\x19\n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xac\x01\x02\n\n\r\n\x05\
    \x04\x0f\x02\x02\x05\x12\x04\xac\x01\x0b\x10\n\r\n\x05\x04\x0f\x02\x02\
    \x01\x12\x04\xac\x01\x11\x14\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xac\
    \x01\x17\x18\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xad\x01\x02,\n\r\n\x05\
    \x04\x0f\x02\x03\x04\x12\x04\xad\x01\x02\n\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\xad\x01\x0b\x10\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xad\x01\
    \x11\x19\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xad\x01\x1c\x1d\n\r\n\x05\
    \x04\x0f\x02\x03\x08\x12\x04\xad\x01\x1e+\n\r\n\x05\x04\x0f\x02\x03\x07\
    \x12\x04\xad\x01)*\n\x0c\n\x04\x04\x0f\x02\x04\x12\x04\xae\x01\x02*\n\r\
    \n\x05\x04\x0f\x02\x04\x04\x12\x04\xae\x01\x02\n\n\r\n\x05\x04\x0f\x02\
    \x04\x05\x12\x04\xae\x01\x0b\x10\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\
    \xae\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x04\x03\x12\x04\xae\x01\x1a\x1b\n\
    \r\n\x05\x04\x0f\x02\x04\x08\x12\x04\xae\x01\x1c)\n\r\n\x05\x04\x0f\x02\
    \x04\x07\x12\x04\xae\x01'(\n\x0c\n\x04\x04\x0f\x02\x05\x12\x04\xaf\x01\
    \x02\"\n\r\n\x05\x04\x0f\x02\x05\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\
    \x0f\x02\x05\x05\x12\x04\xaf\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x05\x01\
    \x12\x04\xaf\x01\x12\x1d\n\r\n\x05\x04\x0f\x02\x05\x03\x12\x04\xaf\x01\
    \x20!\n\x0c\n\x04\x04\x0f\x02\x06\x12\x04\xb0\x01\x02&\n\r\n\x05\x04\x0f\
    \x02\x06\x04\x12\x04\xb0\x01\x02\n\n\r\n\x05\x04\x0f\x02\x06\x06\x12\x04\
    \xb0\x01\x0b\x15\n\r\n\x05\x04\x0f\x02\x06\x01\x12\x04\xb0\x01\x16!\n\r\
    \n\x05\x04\x0f\x02\x06\x03\x12\x04\xb0\x01$%\n\x0c\n\x04\x04\x0f\x02\x07\
    \x12\x04\xb1\x01\x02&\n\r\n\x05\x04\x0f\x02\x07\x04\x12\x04\xb1\x01\x02\
    \n\n\r\n\x05\x04\x0f\x02\x07\x05\x12\x04\xb1\x01\x0b\x0f\n\r\n\x05\x04\
    \x0f\x02\x07\x01\x12\x04\xb1\x01\x10!\n\r\n\x05\x04\x0f\x02\x07\x03\x12\
    \x04\xb1\x01$%\n\"\n\x04\x04\x0f\x02\x08\x12\x04\xb3\x01\x02\x1e\x1a\x14\
    \x20EPICS\x20V4\x20user\x20tag\r\n\n\r\n\x05\x04\x0f\x02\x08\x04\x12\x04\
    \xb3\x01\x02\n\n\r\n\x05\x04\x0f\x02\x08\x05\x12\x04\xb3\x01\x0b\x11\n\r\
    \n\x05\x04\x0f\x02\x08\x01\x12\x04\xb3\x01\x12\x19\n\r\n\x05\x04\x0f\x02\
    \x08\x03\x12\x04\xb3\x01\x1c\x1d\n\xf8\x02\n\x02\x05\0\x12\x06\xba\x01\0\
    \xca\x01\x01\x1a\xe9\x02\x20An\x20enumeration\x20that\x20indicates\x20wh\
    at\x20PB\x20message\x20should\x20be\x20used\x20to\x20unmarshall\x20the\
    \x20following\x20chunk\x20of\x20data\r\n\x20This\x20is\x20a\x20copy\x20o\
    f\x20ArchDBRTypes\x20and\x20the\x20numbers\x20must\x20match\x20the\x20in\
    tegermap\x20in\x20ArchDBRTypes\x20for\x20the\x20reverse\x20lookup\x20to\
    \x20work\x20\x20\r\n\x20Look\x20at\x20DBR2PBTypeMapping\x20to\x20see\x20\
    how\x20we\x20can\x20construct\x20a\x20hashmap\x20that\x20unmarshalls\x20\
    an\x20appropriate\x20language\x20type\x20based\x20on\x20this\x20enum.\r\
    \n\n\x0b\n\x03\x05\0\x01\x12\x04\xba\x01\x05\x10\n\x0c\n\x04\x05\0\x02\0\
    \x12\x04\xbb\x01\x08\x1a\n\r\n\x05\x05\0\x02\0\x01\x12\x04\xbb\x01\x08\
    \x15\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xbb\x01\x18\x19\n\x0c\n\x04\x05\0\
    \x02\x01\x12\x04\xbc\x01\x08\x19\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xbc\
    \x01\x08\x14\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xbc\x01\x17\x18\n\x0c\n\
    \x04\x05\0\x02\x02\x12\x04\xbd\x01\x08\x19\n\r\n\x05\x05\0\x02\x02\x01\
    \x12\x04\xbd\x01\x08\x14\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\xbd\x01\x17\
    \x18\n\x0c\n\x04\x05\0\x02\x03\x12\x04\xbe\x01\x08\x18\n\r\n\x05\x05\0\
    \x02\x03\x01\x12\x04\xbe\x01\x08\x13\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\
    \xbe\x01\x16\x17\n\x0c\n\x04\x05\0\x02\x04\x12\x04\xbf\x01\x08\x18\n\r\n\
    \x05\x05\0\x02\x04\x01\x12\x04\xbf\x01\x08\x13\n\r\n\x05\x05\0\x02\x04\
    \x02\x12\x04\xbf\x01\x16\x17\n\x0c\n\x04\x05\0\x02\x05\x12\x04\xc0\x01\
    \x08\x17\n\r\n\x05\x05\0\x02\x05\x01\x12\x04\xc0\x01\x08\x12\n\r\n\x05\
    \x05\0\x02\x05\x02\x12\x04\xc0\x01\x15\x16\n\x0c\n\x04\x05\0\x02\x06\x12\
    \x04\xc1\x01\x08\x1a\n\r\n\x05\x05\0\x02\x06\x01\x12\x04\xc1\x01\x08\x15\
    \n\r\n\x05\x05\0\x02\x06\x02\x12\x04\xc1\x01\x18\x19\n\x0c\n\x04\x05\0\
    \x02\x07\x12\x04\xc2\x01\x08\x1c\n\r\n\x05\x05\0\x02\x07\x01\x12\x04\xc2\
    \x01\x08\x17\n\r\n\x05\x05\0\x02\x07\x02\x12\x04\xc2\x01\x1a\x1b\n\x0c\n\
    \x04\x05\0\x02\x08\x12\x04\xc3\x01\x08\x1b\n\r\n\x05\x05\0\x02\x08\x01\
    \x12\x04\xc3\x01\x08\x16\n\r\n\x05\x05\0\x02\x08\x02\x12\x04\xc3\x01\x19\
    \x1a\n\x0c\n\x04\x05\0\x02\t\x12\x04\xc4\x01\x08\x1b\n\r\n\x05\x05\0\x02\
    \t\x01\x12\x04\xc4\x01\x08\x16\n\r\n\x05\x05\0\x02\t\x02\x12\x04\xc4\x01\
    \x19\x1a\n\x0c\n\x04\x05\0\x02\n\x12\x04\xc5\x01\x08\x1b\n\r\n\x05\x05\0\
    \x02\n\x01\x12\x04\xc5\x01\x08\x15\n\r\n\x05\x05\0\x02\n\x02\x12\x04\xc5\
    \x01\x18\x1a\n\x0c\n\x04\x05\0\x02\x0b\x12\x04\xc6\x01\x08\x1b\n\r\n\x05\
    \x05\0\x02\x0b\x01\x12\x04\xc6\x01\x08\x15\n\r\n\x05\x05\0\x02\x0b\x02\
    \x12\x04\xc6\x01\x18\x1a\n\x0c\n\x04\x05\0\x02\x0c\x12\x04\xc7\x01\x08\
    \x1a\n\r\n\x05\x05\0\x02\x0c\x01\x12\x04\xc7\x01\x08\x14\n\r\n\x05\x05\0\
    \x02\x0c\x02\x12\x04\xc7\x01\x17\x19\n\x0c\n\x04\x05\0\x02\r\x12\x04\xc8\
    \x01\x08\x1d\n\r\n\x05\x05\0\x02\r\x01\x12\x04\xc8\x01\x08\x17\n\r\n\x05\
    \x05\0\x02\r\x02\x12\x04\xc8\x01\x1a\x1c\n\x0c\n\x04\x05\0\x02\x0e\x12\
    \x04\xc9\x01\x08\x1e\n\r\n\x05\x05\0\x02\x0e\x01\x12\x04\xc9\x01\x08\x18\
    \n\r\n\x05\x05\0\x02\x0e\x02\x12\x04\xc9\x01\x1b\x1d\n\xcc\x01\n\x02\x04\
    \x10\x12\x06\xcf\x01\0\xe3\x01\x01\x1a\xbd\x01\x20A\x20payload\x20info\
    \x20is\x20the\x20first\x20line\x20in\x20a\x20chunk\x20of\x20data\x20sent\
    \x20back\x20to\x20the\x20client.\r\n\x20It\x20tells\x20you\x20how\x20to\
    \x20unmarshall,\x20the\x20pvname\x20and\x20the\x20year\x20for\x20the\x20\
    data\r\n\x20It\x20also\x20has\x20a\x20lot\x20of\x20optional\x20fields\r\
    \n\n\x0b\n\x03\x04\x10\x01\x12\x04\xcf\x01\x08\x13\n\x0c\n\x04\x04\x10\
    \x02\0\x12\x04\xd0\x01\x02\x20\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xd0\
    \x01\x02\n\n\r\n\x05\x04\x10\x02\0\x06\x12\x04\xd0\x01\x0b\x16\n\r\n\x05\
    \x04\x10\x02\0\x01\x12\x04\xd0\x01\x17\x1b\n\r\n\x05\x04\x10\x02\0\x03\
    \x12\x04\xd0\x01\x1e\x1f\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xd1\x01\x02\
    \x1d\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xd1\x01\x02\n\n\r\n\x05\x04\
    \x10\x02\x01\x05\x12\x04\xd1\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x01\x01\
    \x12\x04\xd1\x01\x12\x18\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xd1\x01\
    \x1b\x1c\n\x0c\n\x04\x04\x10\x02\x02\x12\x04\xd2\x01\x02\x1a\n\r\n\x05\
    \x04\x10\x02\x02\x04\x12\x04\xd2\x01\x02\n\n\r\n\x05\x04\x10\x02\x02\x05\
    \x12\x04\xd2\x01\x0b\x10\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xd2\x01\
    \x11\x15\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xd2\x01\x18\x19\n\x0c\n\
    \x04\x04\x10\x02\x03\x12\x04\xd3\x01\x02\"\n\r\n\x05\x04\x10\x02\x03\x04\
    \x12\x04\xd3\x01\x02\n\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\xd3\x01\x0b\
    \x10\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xd3\x01\x11\x1d\n\r\n\x05\x04\
    \x10\x02\x03\x03\x12\x04\xd3\x01\x20!\n\xa9\x01\n\x04\x04\x10\x02\x04\
    \x12\x04\xd7\x01\x02\x1f\x1a\x9a\x01\x20Items\x20from\x205\x20to\x2014\
    \x20are\x20no\x20longer\x20to\x20be\x20used.\x20\r\n\x20Stick\x20these\
    \x20into\x20the\x20headers\x20using\x20the\x20field\x20names\r\n\x20For\
    \x20example,\x20units\x20comes\x20in\x20as\x20EGU\x20in\x20the\x20header\
    s.\r\n\n\r\n\x05\x04\x10\x02\x04\x04\x12\x04\xd7\x01\x02\n\n\r\n\x05\x04\
    \x10\x02\x04\x05\x12\x04\xd7\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x04\x01\
    \x12\x04\xd7\x01\x12\x1a\n\r\n\x05\x04\x10\x02\x04\x03\x12\x04\xd7\x01\
    \x1d\x1e\n\x0c\n\x04\x04\x10\x02\x05\x12\x04\xd8\x01\x02\x1f\n\r\n\x05\
    \x04\x10\x02\x05\x04\x12\x04\xd8\x01\x02\n\n\r\n\x05\x04\x10\x02\x05\x05\
    \x12\x04\xd8\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x05\x01\x12\x04\xd8\x01\
    \x12\x1a\n\r\n\x05\x04\x10\x02\x05\x03\x12\x04\xd8\x01\x1d\x1e\n\x0c\n\
    \x04\x04\x10\x02\x06\x12\x04\xd9\x01\x02\x1f\n\r\n\x05\x04\x10\x02\x06\
    \x04\x12\x04\xd9\x01\x02\n\n\r\n\x05\x04\x10\x02\x06\x05\x12\x04\xd9\x01\
    \x0b\x11\n\r\n\x05\x04\x10\x02\x06\x01\x12\x04\xd9\x01\x12\x1a\n\r\n\x05\
    \x04\x10\x02\x06\x03\x12\x04\xd9\x01\x1d\x1e\n\x0c\n\x04\x04\x10\x02\x07\
    \x12\x04\xda\x01\x02\x1f\n\r\n\x05\x04\x10\x02\x07\x04\x12\x04\xda\x01\
    \x02\n\n\r\n\x05\x04\x10\x02\x07\x05\x12\x04\xda\x01\x0b\x11\n\r\n\x05\
    \x04\x10\x02\x07\x01\x12\x04\xda\x01\x12\x1a\n\r\n\x05\x04\x10\x02\x07\
    \x03\x12\x04\xda\x01\x1d\x1e\n\x0c\n\x04\x04\x10\x02\x08\x12\x04\xdb\x01\
    \x02\x1f\n\r\n\x05\x04\x10\x02\x08\x04\x12\x04\xdb\x01\x02\n\n\r\n\x05\
    \x04\x10\x02\x08\x05\x12\x04\xdb\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x08\
    \x01\x12\x04\xdb\x01\x12\x1a\n\r\n\x05\x04\x10\x02\x08\x03\x12\x04\xdb\
    \x01\x1d\x1e\n\x0c\n\x04\x04\x10\x02\t\x12\x04\xdc\x01\x02\x20\n\r\n\x05\
    \x04\x10\x02\t\x04\x12\x04\xdc\x01\x02\n\n\r\n\x05\x04\x10\x02\t\x05\x12\
    \x04\xdc\x01\x0b\x11\n\r\n\x05\x04\x10\x02\t\x01\x12\x04\xdc\x01\x12\x1a\
    \n\r\n\x05\x04\x10\x02\t\x03\x12\x04\xdc\x01\x1d\x1f\n\x0c\n\x04\x04\x10\
    \x02\n\x12\x04\xdd\x01\x02\x20\n\r\n\x05\x04\x10\x02\n\x04\x12\x04\xdd\
    \x01\x02\n\n\r\n\x05\x04\x10\x02\n\x05\x12\x04\xdd\x01\x0b\x11\n\r\n\x05\
    \x04\x10\x02\n\x01\x12\x04\xdd\x01\x12\x1a\n\r\n\x05\x04\x10\x02\n\x03\
    \x12\x04\xdd\x01\x1d\x1f\n\x0c\n\x04\x04\x10\x02\x0b\x12\x04\xde\x01\x02\
    \x20\n\r\n\x05\x04\x10\x02\x0b\x04\x12\x04\xde\x01\x02\n\n\r\n\x05\x04\
    \x10\x02\x0b\x05\x12\x04\xde\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x0b\x01\
    \x12\x04\xde\x01\x12\x1a\n\r\n\x05\x04\x10\x02\x0b\x03\x12\x04\xde\x01\
    \x1d\x1f\n\x0c\n\x04\x04\x10\x02\x0c\x12\x04\xdf\x01\x02\x20\n\r\n\x05\
    \x04\x10\x02\x0c\x04\x12\x04\xdf\x01\x02\n\n\r\n\x05\x04\x10\x02\x0c\x05\
    \x12\x04\xdf\x01\x0b\x11\n\r\n\x05\x04\x10\x02\x0c\x01\x12\x04\xdf\x01\
    \x12\x1a\n\r\n\x05\x04\x10\x02\x0c\x03\x12\x04\xdf\x01\x1d\x1f\n\x0c\n\
    \x04\x04\x10\x02\r\x12\x04\xe0\x01\x02\x20\n\r\n\x05\x04\x10\x02\r\x04\
    \x12\x04\xe0\x01\x02\n\n\r\n\x05\x04\x10\x02\r\x05\x12\x04\xe0\x01\x0b\
    \x11\n\r\n\x05\x04\x10\x02\r\x01\x12\x04\xe0\x01\x12\x1a\n\r\n\x05\x04\
    \x10\x02\r\x03\x12\x04\xe0\x01\x1d\x1f\n'\n\x04\x04\x10\x02\x0e\x12\x04\
    \xe2\x01\x02#\x1a\x19\x20End\x20of\x20unused\x20elements\r\n\n\r\n\x05\
    \x04\x10\x02\x0e\x04\x12\x04\xe2\x01\x02\n\n\r\n\x05\x04\x10\x02\x0e\x06\
    \x12\x04\xe2\x01\x0b\x15\n\r\n\x05\x04\x10\x02\x0e\x01\x12\x04\xe2\x01\
    \x16\x1d\n\r\n\x05\x04\x10\x02\x0e\x03\x12\x04\xe2\x01\x20\"\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
